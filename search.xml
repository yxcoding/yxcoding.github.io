<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Android Sutdio NDK Cmake 编译案例]]></title>
      <url>http://yxcoding.github.io/2017/05/16/1494933779425/</url>
      <content type="html"><![CDATA[<p>随着Android studio 功能的不断强大和Google老爸的大力推荐， Android 开发已经完全脱离了eclipse，包括NDK开发现在Android studio 也能够非常好的支持。从官网上我们知道Google为我们提供了ndk-build和cmake两种方式来进行native的编译。今天我们要讨论的就是使用cmake来进行配置已经通过具体的实例来讲解开发过程中常用的配置。<br><a id="more"></a></p>
<h1 id="创建C-C-工程"><a href="#创建C-C-工程" class="headerlink" title="创建C/C++工程"></a>创建C/C++工程</h1><p>在创建Android项目过程中我们选择”Include C++ support”选项, C++标准我们选择C++11，这样创建的项目就是一个C/C++ NDK工程了，就能够进行JAVA和C混合编程。<br><img src="http://7xprrr.com1.z0.glb.clouddn.com/1D508D27-F7A3-4CE2-9F90-CE9DFDE449AE.png" alt=""><br>我们将会在CMakeLists.txt中进行编译配置，cpp中我们将会用来存放C/C++源码。</p>
<h1 id="NDK实例"><a href="#NDK实例" class="headerlink" title="NDK实例"></a>NDK实例</h1><p>下面我们将利用两个场景来讲述下怎么配置第三方开源的静态库和动态库，以及系统的标签库和我们自己的C/C++源码。<br>一般情况下我么会将cpp目录修改成jni目录， 我们先在jni目录下新建jniLibs目录，此目录我们将用来存放第三方静态库.a 和动态库so 文件。<br>首先我们在CMakeLists.txt中设置jni目录位置的变量<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义jni c 目录</span></span><br><span class="line">set(JNI_SRC_DIR src/main/jni)</span><br></pre></td></tr></table></figure></p>
<h2 id="利用curl开源库进行网络请求"><a href="#利用curl开源库进行网络请求" class="headerlink" title="利用curl开源库进行网络请求"></a>利用curl开源库进行网络请求</h2><p>curl是C中著名的网络请求跨平台开源库，我们将在linux中编译出curl的静态库.a 文件来引入到我们的项目中进行网络请求开发。<br>关于如何编译出静态库.a文件不是我们今天的重点，就不在描述，可参考<a href="http://blog.csdn.net/byhook/article/details/52187717" target="_blank" rel="external">http://blog.csdn.net/byhook/article/details/52187717</a> 中利用虚拟机编译即可。将armeabi-v7a/libcurl.a 拷贝到jni.jniLibs中，在CMakeLists.txt添加curl静态库<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl</span></span><br><span class="line">add_library(curl STATIC IMPORTED)</span><br><span class="line">set_target_properties(curl PROPERTIES</span><br><span class="line">                     IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/$&#123;JNI_SRC_DIR&#125;/jniLibs/$&#123;ANDROID_ABI&#125;/libcurl.a)</span><br></pre></td></tr></table></figure></p>
<p>curl作为static导入，<code>${CMAKE_SOURCE_DIR}</code>就是当前CMakeLists.txt所在的目录，在引入库文件的时候一定要加上该变量值，不然会报错说是找不到文件，<code>${ANDROID_ABI}</code>标识我们编译的ABI类型，加入我们编译的是armeabi-v7a，那么编译的时候cmake编译器就会在以下路径去查找该文件<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/main/jni/jniLibs/armeabi-v7a/libcurl.a</span><br></pre></td></tr></table></figure></p>
<h3 id="基于libcurl封装HTTP请求类"><a href="#基于libcurl封装HTTP请求类" class="headerlink" title="基于libcurl封装HTTP请求类"></a>基于libcurl封装HTTP请求类</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "CHttpClient.h"</span></span><br><span class="line"><span class="comment">#include &lt;android/log.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LOGE(...) __android_log_print( ANDROID_LOG_ERROR, "yxcoding", __VA_ARGS__ )</span></span><br><span class="line"><span class="comment">#define LOGD(...) __android_log_print( ANDROID_LOG_DEBUG, "yxcoding", __VA_ARGS__ )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="comment">#include &lt;curl/curl.h&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int OnDebug(CURL *, curl_infotype itype, char *pData, size_t size, void *) &#123;</span><br><span class="line">    <span class="keyword">if</span> (itype == CURLINFO_TEXT) &#123;</span><br><span class="line">        <span class="regexp">//printf</span>(<span class="string">"[TEXT]%s\n"</span>, pData);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (itype == CURLINFO_HEADER_IN) &#123;</span><br><span class="line">        printf(<span class="string">"[HEADER_IN]%s\n"</span>, pData);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (itype == CURLINFO_HEADER_OUT) &#123;</span><br><span class="line">        printf(<span class="string">"[HEADER_OUT]%s\n"</span>, pData);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (itype == CURLINFO_DATA_IN) &#123;</span><br><span class="line">        printf(<span class="string">"[DATA_IN]%s\n"</span>, pData);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (itype == CURLINFO_DATA_OUT) &#123;</span><br><span class="line">        printf(<span class="string">"[DATA_OUT]%s\n"</span>, pData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static size_t OnWriteData(void *buffer, size_t size, size_t nmemb, void *lpVoid) &#123;</span><br><span class="line">    std::string *str = (std::string *) lpVoid;</span><br><span class="line">    <span class="keyword">if</span> (NULL == str <span class="params">||</span> NULL == buffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    char *pData = (char *) buffer;</span><br><span class="line">    str-&gt;append(pData, size * nmemb);</span><br><span class="line">    <span class="keyword">return</span> nmemb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CHttpClient::Post(const std::string &amp;strUrl, const std::string &amp;strPost,</span><br><span class="line">                      std::string &amp;strResponse) &#123;</span><br><span class="line">    CURLcode res;</span><br><span class="line">    CURL *curl = curl_easy_init();</span><br><span class="line">    <span class="keyword">if</span> (NULL == curl) &#123;</span><br><span class="line">        <span class="keyword">return</span> CURLE_FAILED_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, strUrl.c_str());</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_POST, <span class="number">1</span>);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, strPost.c_str());</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_READFUNCTION, NULL);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, OnWriteData);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) &amp;strResponse);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_NOSIGNAL, <span class="number">1</span>);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, <span class="number">3</span>);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_TIMEOUT, <span class="number">3</span>);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, <span class="literal">false</span>);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, <span class="literal">true</span>);</span><br><span class="line">    <span class="regexp">//curl</span>_easy_setopt(curl, CURLOPT_PROXY, <span class="string">"10.100.51.13:8888"</span>);</span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res != CURLE_OK) &#123;</span><br><span class="line">        LOGE(<span class="string">"Http Fail, Error Code = %d!"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CHttpClient::addHeader(char *key, const char *value) &#123;</span><br><span class="line">    std::string header = key;</span><br><span class="line">    header += <span class="string">":"</span>;</span><br><span class="line">    header += value;</span><br><span class="line">    LOGD(<span class="string">"http header = %s"</span>, header.c_str());</span><br><span class="line">    headers = curl_slist_append(headers, header.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHttpClient::CHttpClient(void) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHttpClient::~CHttpClient(void) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个坑，我们在进行C/C++ 混合编程的时候，如果在C++中引入的头文件是C语言的，那必须使用extern “C” { … } 包起来，不然编译会不通过。<br>源码写好了，接下来我们就是要配置编译了<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl</span></span><br><span class="line">add_library(curl STATIC IMPORTED)</span><br><span class="line">set_target_properties(curl PROPERTIES</span><br><span class="line">                     IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/$&#123;JNI_SRC_DIR&#125;/jniLibs/$&#123;ANDROID_ABI&#125;/libcurl.a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块定义 </span></span><br><span class="line">add_library( CurlTest</span><br><span class="line">             SHARED</span><br><span class="line">             src/main/jni/native-lib.cpp</span><br><span class="line">             src/main/jni/CHttpClient.cpp )</span><br><span class="line"></span><br><span class="line">target_link_libraries( CurlTest curl $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure></p>
<p>我们将基于curl静态库封装的CHttpClient.cpp 和调用者 native-lib.cpp 一起作为CurlTest 模块一起编译出libCurTest.so 文件。</p>
<p>未完，待续。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WebView JS 注入]]></title>
      <url>http://yxcoding.github.io/2016/09/27/1474977250400/</url>
      <content type="html"><![CDATA[<p>Native + H5 的开发已经成为APP 的主流形式。而往往有时候我们需要对WebView中的网页进行操作，有的可以使用Java 和 JS 互调的形式实现，今天我们来说说 通过向WebView 中的网页注入JS 的方式来操作网页。<br><a id="more"></a><br>我们知道WebView中可以通过<code>webview.loadUrl(&quot;javascript:xxx&quot;);</code>的方式来调用js里面的代码，那么，我们也可以利用<code>webview.loadUrl(&quot;javascript:xxx&quot;);</code> 的方式来加载注入一段 js 代码 。我们 知道WebView 需要通过<code>webView.setWebViewClient(new MyWebClient());</code>的方式来监听网页加载的各个周期方法回调，那么我们只需要在<code>onPageFinished(WebView view, String url)</code> 中注入提前设置好的js 即可，例如:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWebClient</span> <span class="title">extends</span> <span class="title">WebViewClient</span></span></span><br><span class="line">&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onPageFinished(WebView view, String url)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            view.loadUrl(<span class="string">"javascript:"</span> + js);</span><br><span class="line">            view.loadUrl(<span class="string">"javascript:"</span> + <span class="string">"setValue()"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">super</span>.onPageFinished(view, url);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>view.loadUrl(&quot;javascript:&quot; + js);</code>来注入已经定义好的js 代码，接着<code>view.loadUrl(&quot;javascript:&quot; + &quot;setValue()&quot;);</code>来调用注入js中的方法。</p>
<p>完整代码如下</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="title">extends</span> <span class="title">AppCompatActivity</span></span></span><br><span class="line">&#123;</span><br><span class="line">    private WebView webView;</span><br><span class="line"></span><br><span class="line">    private String js;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        webView = (WebView) findViewById(R.id.webview);</span><br><span class="line"></span><br><span class="line">        WebSettings webSettings = webView.getSettings();</span><br><span class="line">        webSettings.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">        <span class="regexp">//web</span>Settings.setDomStorageEnabled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        webView.setWebViewClient(new MyWebClient());</span><br><span class="line"></span><br><span class="line">        webView.loadUrl(<span class="string">"file:///android_asset/test.html"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="regexp">//</span> 本地定义的JS，也可以通过读取URL 中的JS文件 赋值给 js</span><br><span class="line">        js = <span class="string">"javascript:function setValue()&#123;x=document.getElementById(\"content\");  x.innerHTML=\"js 注入成功且方法调用成功\";&#125;"</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyWebClient</span> <span class="title">extends</span> <span class="title">WebViewClient</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onPageFinished(WebView view, String url)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            view.loadUrl(<span class="string">"javascript:"</span> + js);</span><br><span class="line">            view.loadUrl(<span class="string">"javascript:"</span> + <span class="string">"setValue()"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">super</span>.onPageFinished(view, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本案例是加载本地的html，存放在<code>assets/test.html</code>中<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;WebView Js Injection Demo&lt;/h1&gt;</span><br><span class="line">&lt;p id="content"&gt;</span><br><span class="line">    hello,yxcoding</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>该例子其实就是 通过向WebView注入一段 js，改变原来 id=”content” 的 p 标签下的内容 “hello,yxcoing” 为 “js 注入成功且方法调用成功”。效果图如下</p>
<p><img src="https://github.com/yxcoding/WebViewJsInjection/blob/master/device-2016-07-25-100004.png?raw=true" alt=""></p>
<p>我们也可以调用远程的js，也就是通过url 地址的方式调用，例如</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String js = <span class="string">"var appJs = document.createElement(\"script\");"</span>;</span><br><span class="line">js += <span class="string">"appJs.src=\"http://www.yxcoding.net/xxx.js\";"</span>;</span><br><span class="line">js += <span class="string">"document.body.appendChild(appJs);"</span>;</span><br></pre></td></tr></table></figure>
<p>了解JS的同学知道，可以通过DOM操作，向html 添加&lt;script&gt;标签。 但是通过这种方式也许会出现一种问题，那就是 在加载远程的url js 文件的时候是需要时间，那么我们就不能在注入js后就马上调用js 中的方法，那么该怎么办呢？ 熟悉JS 的同学应该知道，有个 onLoad 事件，在页面加载完成的时候触发的事件，那就好办了</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String js = <span class="string">"var appJs = document.createElement(\"script\");"</span>;</span><br><span class="line">js += <span class="string">"appJs.src=\"http://www.yxcoding.net/xxx.js\";"</span>;</span><br><span class="line">js + = <span class="string">"appJs.onload=function()&#123;start();&#125;;"</span>;</span><br><span class="line">js += <span class="string">"document.body.appendChild(appJs);"</span>;</span><br></pre></td></tr></table></figure>
<p>在onload事件中 调用 start() 方法。 </p>
<blockquote>
<p>访问网络资源，不要忘记在AndroidManifest.xml 中添加 &lt;uses-permission android:name=”android.permission.INTERNET”/&gt;权限</p>
</blockquote>
<p>全部代码请参考<a href="https://github.com/yxcoding/WebViewJsInjection" target="_blank" rel="external">WebViewJsInjection</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[自定义View原来是这么一回事！！！]]></title>
      <url>http://yxcoding.github.io/2016/07/19/1468918916781/</url>
      <content type="html"><![CDATA[<p>虽然Android为我们提供了很多的控件，但是在很多情况下， 已经没法满足我们的独特需求，所以这个时候就需要我们根据原理自定义控件，从而解决问题。首先我们来了解下俩个基础概念:<code>View</code> 和 <code>ViewGroup</code>, 而自定义View 最直接的方式就是继承<code>View</code>或者<code>ViewGroup</code>。<br><code>View</code> 是针对单个视图的，它只有它自己，没有其他的视图。而<code>ViewGroup</code>是个视图组合，它可以添加多个<code>View</code>的子类或者多个<code>ViewGroup</code>的子类。<br><a id="more"></a></p>
<p>说到自定义View就不得不说<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>、<br><code>onLayout(boolean changed, int left, int top, int right, int bottom)</code> 和 <code>onDraw(Canvas canvas)</code> 这三个方法。而他们的执行顺序为 <code>Measure-&gt;Layout-&gt;Draw</code></p>
<h1 id="onMeasure-int-widthMeasureSpec-int-heightMeasureSpec"><a href="#onMeasure-int-widthMeasureSpec-int-heightMeasureSpec" class="headerlink" title="onMeasure(int widthMeasureSpec, int heightMeasureSpec)"></a>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</h1><p>这个方法是用来测量的，很好理解，要想在手机上显示一个View，那必须要知道这个View的大小，而这个方法可以用来计算和设置View的大小。测量的时候需要知道两个值:<code>Mode</code> 和 <code>Size</code>。可通过<code>MeasureSpec.getMode(widthMeasureSpec)</code> 和 <code>MeasureSpec.getSize(widthMeasureSpec)</code> 获取。</p>
<p><code>Mode</code> 的形式有三种 <code>MeasureSpec.EXACTLY（精确尺寸）</code>、<code>MeasureSpec.AT_MOST（最大尺寸）</code> <code>MeasureSpec.UNSPECIFIED（未指定尺寸）</code>，第三种并不常见，一般指的是 AdapterView 类型的视图。</p>
<ul>
<li><code>MeasureSpec.EXACTLY（精确尺寸）</code>:  layout_width或layout_height 设置为match_parent 或者指定了具体值的时候如50dp</li>
<li><code>MeasureSpec.AT_MOST（最大尺寸）</code>: layout_width或layout_height指定为WRAP_CONTENT的时候，View的大小一般随着View的子View或内容进行变化，此时控件尺寸只要不超过父控件允许的最大尺寸即可。其实就是 size 不会超过 父控件的最大尺寸。</li>
</ul>
<p>我们来举个例子:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)</span><br><span class="line">    &#123;</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        int heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        int measuredHeight, measuredWidth;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY)</span><br><span class="line">        &#123;</span><br><span class="line">            measuredWidth = widthSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            measuredWidth = <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY)</span><br><span class="line">        &#123;</span><br><span class="line">            measuredHeight = heightSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            measuredHeight = <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setMeasuredDimension(measuredWidth, measuredHeight);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>xml 中</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    <span class="symbol">xmlns:</span>android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="symbol">android:</span>layout_width=<span class="string">"100dp"</span></span><br><span class="line">    <span class="symbol">android:</span>layout_height=<span class="string">"100dp"</span></span><br><span class="line">    <span class="symbol">android:</span>gravity=<span class="string">"center"</span></span><br><span class="line">    <span class="symbol">android:</span>background=<span class="string">"@android:color/holo_red_dark"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;net.yxcoding.customview.CustomView</span><br><span class="line">        <span class="symbol">android:</span>layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        <span class="symbol">android:</span>layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        <span class="symbol">android:</span>background=<span class="string">"@android:color/holo_blue_bright"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/LinearLayout&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下图所示:<br><img src="https://github.com/yxcoding/blog_images/blob/master/CustomView/QQ%E5%9B%BE%E7%89%8720160719173419.png?raw=true" alt=""></p>
<p>如图所示 layout_width 为 match_parent，所以是 <code>MeasureSpec.EXACTLY</code>,<code>measuredWidth = widthSize;</code>最终的宽度就等于match_parent,也就是等于父类的100dp。而 layout_height 是 wrap_content，所以 Mode 是MeasureSpec.AT_MOST, <code>measuredHeight = 50</code>,案例中的最终高度就等于50。</p>
<p>它的测量流程如下图所示<br><img src="https://github.com/yxcoding/blog_images/blob/master/CustomView/abfdab0536252074b67bcc7c05a4be7d.png?raw=true" alt=""></p>
<h1 id="onLayout-boolean-changed-int-left-int-top-int-right-int-bottom"><a href="#onLayout-boolean-changed-int-left-int-top-int-right-int-bottom" class="headerlink" title="onLayout(boolean changed, int left, int top, int right, int bottom)"></a>onLayout(boolean changed, int left, int top, int right, int bottom)</h1><p>这个方法 是针对 View 容器的，一般对于单纯的View 不需要重写该方法。 <code>onLayout</code> 主要针对子View的显示位置，其中的left,top,right,bottom 分别表示显示父控件的举行可用空间（除去margin 和 paadding 的大小）。<br>可在该方法中获取所有子View，并且调用子View 的 <code>layout(int l, int t, int r, int b)</code>来重新摆放位置。例如<code>layout(10,10,100,100)</code>,则说明该View 在距离父控件的左上角位置<code>(10,10)</code>的位置，显示的宽和高则为<code>(r-l, b-t)</code>即<code>(90, 90)</code>。下面我们举个例子，将子View 横向排列，之间间距为 20。</p>
<p>首先将 CustomView 继承 ViewGroup，然后重写下面两个方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onLayout(boolean changed, int left, int top, int right, int bottom)</span><br><span class="line">    &#123;</span><br><span class="line">        Log.d("onLayout", "left=" + left + " top=" + top + " right=" + right + " bottom=" + bottom);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; getChildCount(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            View view = getChildAt(i);</span><br><span class="line">            int measureWidth = view.getMeasuredWidth();</span><br><span class="line">            int measureHeight = view.getMeasuredHeight();</span><br><span class="line">            view.layout(left, top, left + measureWidth, measureHeight + top);</span><br><span class="line">            left += measureWidth + 20;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)</span><br><span class="line">    &#123;</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line"></span><br><span class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        int heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        int measuredHeight = 0, measuredWidth = 0;</span><br><span class="line"></span><br><span class="line">        if (widthMode == MeasureSpec.EXACTLY || widthMode == MeasureSpec.AT_MOST)</span><br><span class="line">        &#123;</span><br><span class="line">            measuredWidth = widthSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (heightMode == MeasureSpec.EXACTLY || heightMode == MeasureSpec.AT_MOST)</span><br><span class="line">        &#123;</span><br><span class="line">            measuredHeight = heightSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 计算孩子View大小</span><br><span class="line">        measureChildren(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        </span><br><span class="line">        setMeasuredDimension(measuredWidth, measuredHeight);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>onMeasure</code>通过<code>measureChildren(widthMeasureSpec, heightMeasureSpec)</code> 计算子View 们的大小，在<code>onLayout</code>中通过<code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code> 获取子View 的大小并且通过已知 left，top，right 和bottom 来重新设置子View的摆放位置。显示效果如下图所示<br><img src="https://github.com/yxcoding/blog_images/blob/master/CustomView/QQ%E5%9B%BE%E7%89%8720160720103312.png?raw=true" alt=""></p>
<h1 id="onDraw-Canvas-canvas"><a href="#onDraw-Canvas-canvas" class="headerlink" title="onDraw(Canvas canvas)"></a>onDraw(Canvas canvas)</h1><p>下面我们来看看最有意思的方法，之所以说它有意思，是因为它可以画很多东西。它就是一个画布，你可以在它上面画出你想要的图案。然后说到<code>Canvas</code> 画布就不得不说<code>Paint</code>画笔了，要想画出东西，得用画笔才行，所以画布告诉系统要画什么，画笔就告诉系统怎么画，需要什么颜色、什么线条宽度等等。例如</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onDraw(Canvas canvas)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="regexp">//</span> 画圆</span><br><span class="line">        paint.setColor(Color.RED);</span><br><span class="line">        <span class="regexp">//</span> 线条宽度</span><br><span class="line">        paint.setStrokeWidth(<span class="number">5</span>);</span><br><span class="line">        canvas.drawCircle(<span class="number">80</span>, <span class="number">80</span>, <span class="number">80</span>, paint);</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> 画矩形</span><br><span class="line">        paint.setColor(Color.BLUE);</span><br><span class="line">        canvas.drawRect(<span class="number">80</span> * <span class="number">2</span> + <span class="number">20</span>, <span class="number">0</span>, getMeasuredWidth() - (<span class="number">80</span> * <span class="number">2</span> + <span class="number">20</span>), getMeasuredHeight() / <span class="number">2</span>, paint);</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> 画线条</span><br><span class="line">        paint.setColor(Color.BLACK);</span><br><span class="line">        paint.setStrokeWidth(<span class="number">10</span>);</span><br><span class="line">        canvas.drawLine(<span class="number">0</span>, getMeasuredHeight() / <span class="number">2</span> + <span class="number">20</span>, getMeasuredWidth() / <span class="number">2</span>, getMeasuredHeight() / <span class="number">2</span> + <span class="number">20</span>, paint);</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> 画文字</span><br><span class="line">        paint.setColor(Color.YELLOW);</span><br><span class="line">        paint.setTextSize(<span class="number">40</span>);</span><br><span class="line">        canvas.drawText(<span class="string">"hello,yxcoding"</span>, getMeasuredHeight() / <span class="number">2</span>, getMeasuredHeight() - <span class="number">40</span>, paint);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果如下图所示<br><img src="https://github.com/yxcoding/blog_images/blob/master/CustomView/QQ%E5%9B%BE%E7%89%8720160720110520.png?raw=true" alt=""></p>
<h1 id="View刷新"><a href="#View刷新" class="headerlink" title="View刷新"></a>View刷新</h1><p>我们常常会去刷新View，从而实现特定的需求。比如 在一个自定义View中有一些动画，这个时候 就需要我们刷新View。那么改如何实现View 刷新呢。android为我们提供了三种刷新的方式 <code>requestLayout()</code>、<code>invalidate()</code>和<code>postInvalidate()</code>。 <code>invalidate()</code>和<code>postInvalidate()</code>和是一样的，只不过<code>postInvalidate()</code> 是在子线程中唤醒刷新操作，<br>它们俩 只会调用draw 即使 并没有什么变化。而 <code>requestLayout()</code> 顾名思义，当布局发生变化的时候会调用measure和layout等和布局有关的操作。<br>所以总结一下就是，布局发生变化调用 <code>requestLayout()</code>；当需要执行刷新动画的时候可以执行<code>postInvalidate()</code>。 或<code>invalidate()</code>从而唤醒<code>onDraw()</code>中的代码。 根据上面的案例我们改造一下</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void startAnimation()</span><br><span class="line">    &#123;</span><br><span class="line">        animator = ValueAnimator.ofFloat(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationUpdate(ValueAnimator animation)</span><br><span class="line">            &#123;</span><br><span class="line">                scale = (float) animation.getAnimatedValue();</span><br><span class="line">                postInvalidate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> 重复执行动画</span><br><span class="line">        animator.setRepeatCount(-<span class="number">1</span>);</span><br><span class="line">        <span class="regexp">//</span> 重复模式为 从初始状态开始</span><br><span class="line">        animator.setRepeatMode(ValueAnimator.REVERSE);</span><br><span class="line">        animator.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="regexp">//</span> 画圆</span><br><span class="line">        paint.setColor(Color.RED);</span><br><span class="line">        <span class="regexp">//</span> 线条宽度</span><br><span class="line">        paint.setStrokeWidth(<span class="number">5</span>);</span><br><span class="line">        canvas.drawCircle(<span class="number">80</span>, <span class="number">80</span>, <span class="number">80</span> * scale, paint);</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> 画矩形</span><br><span class="line">        paint.setColor(Color.BLUE);</span><br><span class="line">        canvas.drawRect(<span class="number">80</span> * <span class="number">2</span> + <span class="number">20</span>, <span class="number">0</span>, getMeasuredWidth() - (<span class="number">80</span> * <span class="number">2</span> + <span class="number">20</span>) * scale, getMeasuredHeight() / <span class="number">2</span> * scale, paint);</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> 画线条</span><br><span class="line">        paint.setColor(Color.BLACK);</span><br><span class="line">        paint.setStrokeWidth(<span class="number">10</span>);</span><br><span class="line">        canvas.drawLine(<span class="number">0</span>, getMeasuredHeight() / <span class="number">2</span> + <span class="number">20</span>, getMeasuredWidth() / <span class="number">2</span> * scale, getMeasuredHeight() / <span class="number">2</span> + <span class="number">20</span>, paint);</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> 画文字</span><br><span class="line">        paint.setColor(Color.YELLOW);</span><br><span class="line">        paint.setTextSize(<span class="number">40</span> * scale);</span><br><span class="line">        canvas.drawText(<span class="string">"hello,yxcoding"</span>, getMeasuredHeight() / <span class="number">2</span>, getMeasuredHeight() - <span class="number">40</span>, paint);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因为以上的动画是重复执行的，所以在动画的回调接口中会不断的调用<code>postInvalidate</code>刷新View，而在onDraw()中通过每次计算的scale 来设置绘画的系数，从而达到以下图中的动画效果<br><img src="https://github.com/yxcoding/blog_images/blob/master/CustomView/ondrwa.gif?raw=true" alt=""></p>
<h1 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h1><p>我们再写xml布局的时候，会有很多的属性值需要设置，如<code>android:layout_width=&quot;match_parent&quot;</code>,我们会发现属性设置有三部分: 命名空间：属性名称 = 属性值，那么 我们也按照这种格式自定义属性。大致分为以下步骤：</p>
<ol>
<li>在res/values 下定义attrs.xml 文件，如下所示：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;declare-styleable name="CustomView"&gt;</span><br><span class="line">        &lt;attr name="circleColor" format="color" /&gt;</span><br><span class="line">        &lt;attr name="rectColor" format="color" /&gt;</span><br><span class="line">        &lt;attr name="lineColor" format="color" /&gt;</span><br><span class="line">        &lt;attr name="textColor" format="color"/&gt;</span><br><span class="line">        &lt;attr name="circleRadius" format="dimension" /&gt;</span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
<p>CustomView是我们在代码中获取该属性集合的凭证，format 代表的是该属性的 值类型，例如color 代表是颜色值，dimension 代表了尺寸长度值等等。</p>
<ol>
<li>在xml 布局中定义命名空间和使用</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;!--定义命名空间， 在gradle中不用使用包名后缀，使用 /res-auto--&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    <span class="symbol">xmlns:</span>android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="symbol">xmlns:</span>custom=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    <span class="symbol">android:</span>layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    <span class="symbol">android:</span>layout_height=<span class="string">"wrap_content"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;net.yxcoding.customview.CustomView</span><br><span class="line">        <span class="symbol">android:</span>layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        <span class="symbol">android:</span>layout_height=<span class="string">"200dp"</span></span><br><span class="line">        <span class="symbol">android:</span>layout_margin=<span class="string">"10dp"</span></span><br><span class="line">        <span class="symbol">android:</span>background=<span class="string">"@android:color/holo_blue_bright"</span></span><br><span class="line">        <span class="symbol">custom:</span>circleColor=<span class="string">"#ff0000"</span></span><br><span class="line">        <span class="symbol">custom:</span>circleRadius=<span class="string">"40dp"</span></span><br><span class="line">        <span class="symbol">custom:</span>lineColor=<span class="string">"#0000ff"</span></span><br><span class="line">        <span class="symbol">custom:</span>rectColor=<span class="string">"#00ff00"</span></span><br><span class="line">        <span class="symbol">custom:</span>textColor=<span class="string">"#ffffff"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/LinearLayout&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>然后在代码中 就可以这样获取我们自定义的属性值了</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public CustomView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line"></span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CustomView);</span><br><span class="line"></span><br><span class="line">        circleColor = a.getColor(R.styleable.CustomView_circleColor, <span class="number">0x000000</span>);</span><br><span class="line">        rectColor = a.getColor(R.styleable.CustomView_rectColor, <span class="number">0x000000</span>);</span><br><span class="line">        lineColor = a.getColor(R.styleable.CustomView_lineColor, <span class="number">0x000000</span>);</span><br><span class="line">        textColor = a.getColor(R.styleable.CustomView_textColor, <span class="number">0x000000</span>);</span><br><span class="line"></span><br><span class="line">        circleRadius = a.getDimension(R.styleable.CustomView_circleRadius, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        a.recycle();</span><br><span class="line"></span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过对应的属性值格式 来获取相应的属性值，例如 颜色值 就是<code>getColor()</code>, 尺寸大小就是<code>getDimension()</code>。最后通过调用<code>a.recycle()</code> 来释放回收资源。获取到自定义属性值后，就可以在<code>onDraw</code> 中 设置了。效果如下图所示<br><img src="https://raw.githubusercontent.com/yxcoding/blog_images/master/CustomView/QQ%E5%9B%BE%E7%89%8720160720160338.png" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上阐述了一些 常用的自定义View 的方式，通过继承和重写相应的方法来重构View。还有一种方式就是通过 LayoutInflater 从已知xml布局文件中 获取定义布局View。另外，在自定义View过程中，会处理一些事件处理onTouchEvent，具体的可参考 <a href="http://blog.csdn.net/bigconvience/article/details/26456359" target="_blank" rel="external">Android的Touch系统简介（一） </a> 和 <a href="">Android Touch系统简介（二）:实例详解onInterceptTouchEvent与onTouchEvent的调用过程 </a> 两篇文章。</p>
<p>学会自定义View 能够帮助我们更加深入的了解android页面View 的原理，同时同事能够为我们带来无限的可能。大家加油！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gradle-experimental 构建NDK 项目]]></title>
      <url>http://yxcoding.github.io/2016/07/14/1468488502586/</url>
      <content type="html"><![CDATA[<p>记得刚从Eclipse 转向Android Studio 进行开发的时候，对于搭建NDK 开发环境让人头疼。网上关于AS NDK 开发环境搭建的资料不是很全面，后来经过慢慢的摸索，最终把之前的项目跑起来了。后来，随着AS版本不断的升级，AS 对NDK开发的功能越来越强大，在经历不用命令行生成C/C++ 文件后（通过Setting-&gt;Tools-&gt;External Tools添加<code>javah</code>、<code>ndk-build</code>和<code>ndk-build clean</code> 命令,然后只需在带<code>native</code>方法的类上右击-&gt;External Tools 选择快捷命令即可，如图1），后来又发现<code>Gradle</code> 的一个插件 <code>gradle-experimental</code>，能够让我们快捷方便更加不用配置<code>Application.mk</code>和<code>Android.mk</code>，而且对C/C++的支持更加强大，再也没有报红了！</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/yxcoding/NDKDemo/master/pic1.png" alt="">图1</p>
<blockquote>
<p>Android Studio 版本最好升级到最新版<br>Gradle版本&gt;2.1.0<br>新建一个android 工程 NDKDemo 如图2所示<br>在项目中的local.properties 添加 NDK 环境路径  ndk.dir=你的ndk路径</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/yxcoding/NDKDemo/master/pic2.png" alt="">图2</p>
<h1 id="创建NDK-Model-支持"><a href="#创建NDK-Model-支持" class="headerlink" title="创建NDK Model 支持"></a>创建NDK Model 支持</h1><p>在含有NDK编程的项目中，本人习惯创建NDK 模块，将关于<code>jni</code>的配置和代码放在NDK模块中，例如图2中的<code>NDKUtil</code> 模块，然后将<code>NDKUtil</code>引入<code>app</code> 中。在<code>NDKUtil</code>模块上<code>右击-&gt;New-&gt;Folder-&gt;JNIFolder</code> 创建jni 目录。</p>
<h1 id="修改build-gradle-配置"><a href="#修改build-gradle-配置" class="headerlink" title="修改build.gradle 配置"></a>修改build.gradle 配置</h1><p>因为我们使用了<code>gradle-experimental</code>(<a href="http://mvnrepository.com/artifact/com.android.tools.build/gradle-experimental" target="_blank" rel="external">查看gradle-experimental版本更新</a>)来构建NDK， 所以，我们首先要添加 该插件的依赖，并且修改相关配置选项。<code>NDKUtil</code>中<code>build.gradle</code>修改为一下形式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 注意这里 要将原来的com.android.library 改成 com.android.model.library</span><br><span class="line">apply plugin: 'com.android.model.library'</span><br><span class="line"></span><br><span class="line">model &#123;</span><br><span class="line">    android &#123;</span><br><span class="line">        compileSdkVersion 23</span><br><span class="line">        buildToolsVersion "23.0.3"</span><br><span class="line"></span><br><span class="line">        defaultConfig &#123;</span><br><span class="line">            // 注意 要添加.apiLevel ,否则会报错</span><br><span class="line">            minSdkVersion.apiLevel 14</span><br><span class="line">            targetSdkVersion.apiLevel 23</span><br><span class="line">        &#125;</span><br><span class="line">        buildTypes &#123;</span><br><span class="line">            release &#123;</span><br><span class="line">                minifyEnabled false</span><br><span class="line">                // 修改成add 的形式 添加混淆文件</span><br><span class="line">                proguardFiles.add(file('proguard-rules.pro'))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ndk &#123;</span><br><span class="line">            // 模块名称</span><br><span class="line">            moduleName "ndkLib"</span><br><span class="line">            abiFilters.addAll(['armeabi', 'armeabi-v7a','x86'])</span><br><span class="line">            ldLibs.addAll(['log'])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    // 添加 gradle-experimental 依赖</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath 'com.android.tools.build:gradle-experimental:0.7.2'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: 'libs', include: ['*.jar'])</span><br><span class="line">    testCompile 'junit:junit:4.12'</span><br><span class="line">    compile 'com.android.support:appcompat-v7:23.3.0'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="生成jni-文件"><a href="#生成jni-文件" class="headerlink" title="生成jni 文件"></a>生成jni 文件</h1><p>在配置以上参数和选项后，接着在java 中创建<code>native</code> 方法类，并且载入ndk 模块，如下图所示<br><img src="https://raw.githubusercontent.com/yxcoding/NDKDemo/master/pic3.png" alt=""><br>我们会发现<code>native</code>方法会报红，如图所示按<code>Alt + Enter</code>，选择第一项 即可在<code>jni</code>中自动创建<code>ndkLib.c</code>文件， 对的，<code>.h</code>头文件 没了…</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;jni.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;android/log.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define  LOG_TAG "NDKUtil"</span></span><br><span class="line"><span class="comment">#define  LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG,__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_net_yxcoding_ndkutil_NDKUtil_getString(JNIEnv *env, jclass type) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> TODO</span><br><span class="line">    LOGD(<span class="string">"执行"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, <span class="string">"Hello, yxcoding"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编写好C/C++ 程序后，直接<code>Rebuild Project</code> 即可在下图所指目录下生成so 文件</p>
<p><img src="https://raw.githubusercontent.com/yxcoding/NDKDemo/master/pic4.png" alt=""></p>
<h1 id="jni-调用"><a href="#jni-调用" class="headerlink" title="jni 调用"></a>jni 调用</h1><p>那么在<code>app</code>模块中直接调用该方法<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="title">extends</span> <span class="title">AppCompatActivity</span></span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        TextView tvName = (TextView) findViewById(R.id.tvName);</span><br><span class="line">        tvName.setText(NDKUtil.getString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>详细代码请见 <a href="!https://github.com/yxcoding/NDKDemo">NDKDemo</a></p>
<p><img src="https://raw.githubusercontent.com/yxcoding/NDKDemo/master/pic5.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ViewPager + Fragment 最优懒加载]]></title>
      <url>http://yxcoding.github.io/2016/07/13/1468374159777/</url>
      <content type="html"><![CDATA[<p><code>ViewPager</code> + <code>Fragment</code> 已经成为现在主流的APP 界面搭建方式， 例如我们最常见的微信，主界面就是使用了<code>ViewPager</code> + <code>Fragment</code>，通过<code>ViewPager</code>来创建和管理四个子页面<code>Fragment</code>。</p>
<p>但是，这种方式有一种缺点让人头疼， 那就是 <code>Fragment预加载</code>。也就是说 当加载第1个fragment 的时候 会自动加载第二个fragment，加载第二个fragment的时候会自动加载第三个fragment，以此类推…但是实际情况我们希望的是当选择哪个页面的时候再去加载数据资源。那么我们该怎么做呢？<br><a id="more"></a><br>我们可以使用一种方式来避免预加载的时候去加载数据，只去初始化UI，这样就提出了 “懒加载” 的算法。我们可以在<code>Fragment</code>的生命周期中 来控制成员变量从而判断加载数据的时机。下面我们就来看看代码的实现。</p>
<blockquote>
<p>为了更好的展示ViewPager + Fragment 显示的效果，我们使用TabLayout 这个控件来实现：<br>添加TabLayout 引用库<br>compile ‘com.android.support:design:23.+’</p>
</blockquote>
<p>首先来创建一个懒加载的父类<code>LazyFragment</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * User: yxfang</span><br><span class="line"> * Date: 2016-07-13</span><br><span class="line"> * Time: 10:02</span><br><span class="line"> * ------------- Description -------------</span><br><span class="line"> * 定义懒加载Fragment 基类，用来实现懒加载算法</span><br><span class="line"> * ---------------------------------------</span><br><span class="line"> */</span><br><span class="line">public abstract class LazyFragment extends BaseFragment</span><br><span class="line">&#123;</span><br><span class="line">    // 当前Fragment 是否可见</span><br><span class="line">    protected boolean isVisible = false;</span><br><span class="line">    // 是否加载过数据</span><br><span class="line">    protected boolean isLoadData = false;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setUserVisibleHint(boolean isVisibleToUser)</span><br><span class="line">    &#123;</span><br><span class="line">        super.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">        this.isVisible = isVisibleToUser;</span><br><span class="line">        preLoadData(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityCreated(@Nullable Bundle savedInstanceState)</span><br><span class="line">    &#123;</span><br><span class="line">        super.onActivityCreated(savedInstanceState);</span><br><span class="line">       	this.isViewInit = true;</span><br><span class="line">        // 防止一开始加载的时候未 调用 preLoadData 方法， 因为setUserVisibleHint 比 onActivityCreated 触发 前</span><br><span class="line">        if (getUserVisibleHint())</span><br><span class="line">        &#123;</span><br><span class="line">            preLoadData(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 子类加载数据</span><br><span class="line">     */</span><br><span class="line">    protected abstract void loadData();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当UI初始化成功，UI可见并且没有加载过数据的时候 加载数据</span><br><span class="line">     *</span><br><span class="line">     * @param forceLoad 强制加载数据</span><br><span class="line">     */</span><br><span class="line">    public void preLoadData(boolean forceLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        if (isViewInit &amp;&amp; isVisible &amp;&amp; (!isLoadData || forceLoad))</span><br><span class="line">        &#123;</span><br><span class="line">            loadData();</span><br><span class="line">            isLoadData = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的<code>isViewInit</code> <code>isVisible</code> <code>isLoadData</code>就是用来控制懒加载的。每当预先加载Fragment的时候，只会去加载UI而并不会加载数据资源，只有当当前Fragment 可见并且之前没有加载过的时候才会去加载数据。通过实现父类<code>LazyFragment</code>的抽象方法<code>loadData()</code>来执行网络数据的加载。<a href="https://github.com/yxcoding/ViewPager-LazyFragment" target="_blank" rel="external">详细代码</a><br><img src="https://github.com/yxcoding/ViewPager-LazyFragment/blob/master/Screenshot_2016-07-13-14-38-19.png?raw=true" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RxJava+Retrofit 构建网络请求处理方式]]></title>
      <url>http://yxcoding.github.io/2016/07/08/1467969481356/</url>
      <content type="html"><![CDATA[<p>大概在几个月之前， 在CSDN上看见了RxJava这样的一个 新名词，但是也没有太注意，所以也就没去看它。但是过了一段时间，发现网上很多关于RxJava的博客和总结，Github上面的一些开源项目也都用到了RxJava，所以就决定开始研究这个神秘而又新颖的东西。起初看RxJava 很难理解，后来慢慢的也就理解了。<br><a id="more"></a></p>
<h1 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h1><p>首先，RxJava是个什么鬼？<br>“a library for composing asynchronous and event-based programs using observable sequences for the Java VM”，翻译一下就是“一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库”，总结一下RxJava 就是一个可异步处理基于序列事件的开源库。卧槽，看到这，是不是脑子里浮想翩翩呀？哈哈</p>
<blockquote>
<p>通过Android Studio中引入RxJava RxAndroid 和Retrofit 开发库，在app模块中的build.gradle 中复制以下代码<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'io.reactivex:rxandroid:1.2.1'</span></span><br><span class="line">compile <span class="string">'io.reactivex:rxjava:1.1.6'</span></span><br><span class="line">compile <span class="string">'com.squareup.retrofit2:retrofit:2.1.0'</span></span><br><span class="line">compile <span class="string">'com.squareup.retrofit2:adapter-rxjava:2.1.0'</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>先来一丢RxJava的代码，看看它的代码风格<br>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 创建被观察者</span><br><span class="line">Observable.create(new Observable.OnSubscribe&lt;String&gt;()  &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void call(Subscriber&lt;? super String&gt; subscriber)  &#123;</span><br><span class="line">           		// 通知观察者</span><br><span class="line">                subscriber.onNext("Hello");</span><br><span class="line">                subscriber.onNext("yxcoding");</span><br><span class="line">                subscriber.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">    // 注册观察者</span><br><span class="line"> &#125;).subscribe(new Subscriber&lt;String&gt;()	&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onCompleted()</span><br><span class="line">            &#123;</span><br><span class="line">                Log.d("Subscriber", "onCompleted");</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable e)</span><br><span class="line">            &#123;</span><br><span class="line">                Log.e("Subscriber", "onError");</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(String s)</span><br><span class="line">            &#123;</span><br><span class="line">            	// 接收到通知，处理</span><br><span class="line">                Log.d("Subscriber", "onNext = " + s);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>代码逻辑清晰简洁。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>A 对 B 进行观察监听， A 是观察者， B就是被观察者。当B状态有改变时，就会通知它的观察者，这样 A 就会进行相应的操作，这就是我们所说的 观察者模式。RxJava 的观察者模式又是怎么样的呢？</p>
<p>首先我们来了解下RxJava 中的几个基本概念：<code>Observable</code>(可观察者，即被观察者)、 <code>Observer</code> (观察者)、 <code>subscribe</code> (订阅)、事件。<code>Observable</code>和 <code>Observer\ Subscriber</code>通过 <code>subscribe()</code> 方法实现订阅关系，从而 <code>Observable</code>可以在需要的时候发出事件来通知 <code>Observer</code>。</p>
<p><code>Observer</code>和 <code>Subscriber</code>都是作为被观察者， 提供了相应的回调方法。<code>Subscriber</code>是对<code>Observer</code> 进行了扩展， 两者使用方法一样。<code>Subscriber</code>增加了<code>onStart()</code>回调方法，值得注意的是 <code>onStart()</code> 是在<code>subscribe()</code>  触发的线程中被调用， 不能指定线程。如果要想在指定线程中使用，可以使用<code>doOnSubscribe()</code>。</p>
<h3 id="创建被观察者"><a href="#创建被观察者" class="headerlink" title="创建被观察者"></a>创建被观察者</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;()</span><br><span class="line"> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void call(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span><br><span class="line">            &#123;</span><br><span class="line">                subscriber.onNext(<span class="string">"Hello"</span>);</span><br><span class="line">                subscriber.onNext(<span class="string">"yxcoding"</span>);</span><br><span class="line">                subscriber.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>除了通过<code>create()</code>创建之外， RxJava 还提供了两种快捷方式<br><code>&lt;T&gt; Observable&lt;T&gt; just(T t1,.......)</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.just(<span class="string">"Hello"</span>, <span class="string">"yxcoding"</span>);</span><br></pre></td></tr></table></figure></p>
<p>依次传入参数。<br>还可通过数组形式传入<br><code>&lt;T&gt; Observable&lt;T&gt; from(T[] array)</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.from(new String[]&#123;<span class="string">"hello"</span>, <span class="string">"yxcoding"</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="创建观察-订阅者"><a href="#创建观察-订阅者" class="headerlink" title="创建观察/订阅者"></a>创建观察/订阅者</h3><p>被观察者创建好之后，需要创建观察者进行注册监听<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Subscriber subscriber = new Subscriber&lt;String&gt;()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void onCompleted()</span><br><span class="line">&#123;</span><br><span class="line">Log.d(<span class="string">"Subscriber"</span>, <span class="string">"onCompleted"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onError(Throwable e)</span><br><span class="line">&#123;</span><br><span class="line">Log.e(<span class="string">"Subscriber"</span>, <span class="string">"onError"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onNext(String s)</span><br><span class="line">&#123;</span><br><span class="line">Log.d(<span class="string">"Subscriber"</span>, <span class="string">"onNext = "</span> + s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>观察者的三个回调方法中，<code>onNext()</code> 会被调用多次，<code>onCompleted()</code> 和<code>onError(Throwable)</code> 只会被调用一次且两者之间只会调用一个。   </p>
<h3 id="观察者-订阅-被观察者"><a href="#观察者-订阅-被观察者" class="headerlink" title="观察者 订阅 被观察者"></a>观察者 订阅 被观察者</h3><p>当观察者与被观察者 创建好之后，通过<code>observable.subscribe(subscriber)</code>建立订阅关系， 一旦调用<code>observable.subscribe(subscriber)</code>，就会触发 被观察者Obserable中的<code>call()</code>方法进行事件发送。<br><code>subscriber.onNext(&quot;Hello&quot;);</code> 发送事件通知到subscriber中的<code>onNext(T t)</code>方法。</p>
<p>除了通过<code>observable.subscribe(subscriber/observer)</code>建立订阅关系外， RxJava 还提供了不完整定义的回调， RxJava 会自动根据自己定义的创建出Subsriber，例如<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello"</span>, <span class="string">"yxcoding"</span>).subscribe(new Action1&lt;String&gt;()</span><br><span class="line">&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void call(String s)</span><br><span class="line">  &#123;</span><br><span class="line"> 	 Log.d(<span class="string">"Subscriber"</span>, s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>将传入的数字数组依次的打印出来<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(new String[] &#123;<span class="string">"Hello"</span>, <span class="string">"yxcoding"</span>&#125;).subscribe(new Action1&lt;String&gt;()</span><br><span class="line">&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void call(String s)</span><br><span class="line">  &#123;</span><br><span class="line"> 	 Log.d(<span class="string">"Subscriber"</span>, s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="事件序列对象加工处理（变换）"><a href="#事件序列对象加工处理（变换）" class="headerlink" title="事件序列对象加工处理（变换）"></a>事件序列对象加工处理（变换）</h2><p>以上说到都是最基本的观察者模式交互，即使不适用RxJava，也能用其他的方式实现。在日常开发中我们会碰到这样的情况，在返回的对象中，我们需要对对象进行加工处理，然后再返回。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>例如下面的例子：<br>当我们传入一张图片的 字符串地址的时候<code>yxcoding/image/logo.png</code>, 一般的做法是 将 它转化为<code>bitmap</code>然后再显示，而在RxJava 中，只需要通过<code>map()</code>来将序列事件中的对象值进行加工即可<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"yxcoding/image/logo.png"</span>) </span><br><span class="line">    .map(new Func1&lt;String, Bitmap&gt;() &#123;</span><br><span class="line">     	<span class="regexp">//</span> 参数类型 String</span><br><span class="line">        @Override</span><br><span class="line">        public Bitmap call(String path) &#123;</span><br><span class="line">			<span class="regexp">//</span> 返回类型 Bitmap</span><br><span class="line">            <span class="keyword">return</span> getBitmapFromPath(filePath); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(new Action1&lt;Bitmap&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(Bitmap bitmap) &#123;</span><br><span class="line">        	 <span class="regexp">//</span> 参数类型 Bitmap</span><br><span class="line">            imageview.setImageBitmap(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>那么，也许你会问，<code>Func1</code> 是个什么鬼？ 怎么不用<code>Action1</code>了？ 细心的话，你会发现<code>Func1</code>中<code>call()</code>是有返回值的，而<code>Action1</code>中没有，其他的用法都一样。</p>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h3><p><code>flatMap()</code>相对于<code>map()</code>来说稍微要复杂一点， 但它们的作用都是对序列事件中的对象 进行加工处理然后再返回。但是<code>flatMap()</code>返回的是<code>Observable</code>,<code>flatMap()</code>将发送的时间都集合在同一个<code>Observable</code>, 然后在统一交给<code>Subscriber \observer</code>。程序员还是看代码吧，废话真多</p>
<blockquote>
<p>例子：传入用户列表，输出用户的收藏列表</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Collect&gt; collectList = new ArrayList&lt;&gt;();</span><br><span class="line">collectList.add(new Collect(<span class="number">1</span>, <span class="string">"collect1"</span>));</span><br><span class="line">collectList.add(new Collect(<span class="number">2</span>, <span class="string">"collect2"</span>));</span><br><span class="line">collectList.add(new Collect(<span class="number">3</span>, <span class="string">"collect"</span>));</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class="line">userList.add(new User(<span class="number">1</span>, <span class="string">"user1"</span>, collectList));</span><br><span class="line">userList.add(new User(<span class="number">2</span>, <span class="string">"user2"</span>, collectList));</span><br><span class="line">userList.add(new User(<span class="number">3</span>, <span class="string">"user3"</span>, collectList));</span><br><span class="line"></span><br><span class="line">Observable.from(userList).flatMap(new Func1&lt;User, Observable&lt;Collect<span class="meta">&gt;&gt;</span>()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public Observable&lt;Collect&gt; call(User student)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="regexp">//</span> 通过from 方式创建Observable 返回</span><br><span class="line">	<span class="keyword">return</span> Observable.from(student.getCollectList());</span><br><span class="line">&#125;</span><br><span class="line">&#125;).subscribe(new Subscriber&lt;Collect&gt;()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void onCompleted()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onError(Throwable e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onNext(Collect collect)</span><br><span class="line">&#123;</span><br><span class="line">	Log.d(<span class="string">"Subscriber"</span>, collect.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Scheduler-线程控制"><a href="#Scheduler-线程控制" class="headerlink" title="Scheduler  线程控制"></a>Scheduler  线程控制</h2><p>前面提到，RxJava是线程不变的， 在那个线程调用<code>subscribe()</code>，就在哪个发送事件和处理事件，要想控制线程，就需要使用到<code>Scheduler</code>调度器。<code>Scheduler</code>提供一下集中类型的线程使用场景</p>
<ul>
<li><code>Schedulers.immediate()</code>: 直接在当前线程运行，相当于不指定线程。这是默认的 <code>Scheduler</code>。</li>
<li><code>Schedulers.newThread()</code>: 总是启用新线程，并在新线程执行操作。</li>
<li><code>Schedulers.io()</code>: I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 <code>Scheduler</code>。行为模式和 <code>newThread()</code> 差不多，区别在于 <code>io()</code> 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 <code>io()</code> 比 <code>newThread()</code>更有效率。不要把计算工作放在<code>io()</code>中，可以避免创建不必要的线程。</li>
<li><code>Schedulers.computation()</code>: 计算所使用的 <code>Scheduler</code>。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 <code>Scheduler</code> 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 <code>computation()</code> 中，否则 I/O 操作的等待时间会浪费 CPU。</li>
</ul>
<p>另外， Android 还有一个专用的 <code>AndroidSchedulers.mainThread()</code>，它指定的操作将在 Android 主线程运行。在日常开发过程中，使用做多的就是 <code>Schedulers.io()</code>。RxJava 中 使用<code>subscribeOn()</code>来指定<code>subscribe()</code>触发/事件产生的线程，通过<code>observeOn()</code>来指定事件处理的线程，典型的例子就是网络请求数据和刷新UI界面。<br>下面我们通过代码来验证下<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).subscribeOn(Schedulers.io())</span><br><span class="line">   .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">   .subscribe(new Action1&lt;Integer&gt;()</span><br><span class="line">   &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void call(Integer integer)</span><br><span class="line">     &#123;</span><br><span class="line">    		 Log.d(<span class="string">"Subscriber"</span>, Thread.currentThread().getName() + <span class="string">"  "</span> + integer);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>输入的结果是<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main <span class="number">1</span></span><br><span class="line">main <span class="number">2</span></span><br><span class="line">main <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h1 id="RxJava-Retrofit-结合了"><a href="#RxJava-Retrofit-结合了" class="headerlink" title="RxJava + Retrofit 结合了"></a>RxJava + Retrofit 结合了</h1><p>关于Retrofit 的介绍和使用，请参考<a href="/2016/06/24/1466752925430/">Android 网络请求框架哪家强?</a>一文。<br>首先利用Retrofit 定义一下接口<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@POST(<span class="string">"onebox/news/query"</span>)</span><br><span class="line">Observable&lt;Result&lt;List&lt;News<span class="meta">&gt;&gt;&gt; </span>newsList(@Query(<span class="string">"key"</span>) String key, @Query(<span class="string">"q"</span>) String q);</span><br></pre></td></tr></table></figure></p>
<p>利用RxJava 我们可以这样</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">RetrofitUtil.getInstance().createService(RetrofitService.<span class="keyword">class</span>).newsList(<span class="string">"5173fa20d74cf85747dcf6f4636856af"</span>, <span class="string">"\"\""</span>)</span><br><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.doOnSubscribe(new Action<span class="number">0</span>()</span><br><span class="line">&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void call()</span><br><span class="line">  &#123;</span><br><span class="line"> 	 showLoadingDialog();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribeOn(AndroidSchedulers.mainThread())</span><br><span class="line">.observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">.subscribe(new Subscriber&lt;Result&lt;List&lt;News<span class="meta">&gt;&gt;&gt;</span>()</span><br><span class="line">&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void onCompleted()</span><br><span class="line">  &#123;</span><br><span class="line">  	closeLoadingDialog();</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public void onError(Throwable e)</span><br><span class="line">  &#123;</span><br><span class="line">    closeLoadingDialog();</span><br><span class="line">    setResult(<span class="literal">false</span>, e.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onNext(Result&lt;List&lt;News<span class="meta">&gt;&gt; </span>result)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.getError_code() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	List&lt;News&gt; list = result.getResult();</span><br><span class="line">      <span class="keyword">if</span> (list != null &amp;&amp; !list.isEmpty())</span><br><span class="line">      &#123;</span><br><span class="line">        StringBuffer sb = new StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (News news : list)</span><br><span class="line">        &#123;</span><br><span class="line">        sb.append(news.getFull_title() + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      	setResult(<span class="literal">true</span>, sb.toString());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    	setResult(<span class="literal">true</span>, result.getReason());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>有些人会问，这么复杂，我用其它的方式也能实现，而且还能比这简单很多。的确，针对普通简单的业务需求来说，这种方式确实搞复杂了。但是， 我们再来看一种场景：</p>
<blockquote>
<p>场景：判断请求接口返回，检测token 是否失效, 如果失效，提示用户用户并且跳转到登录页面</p>
</blockquote>
<p>针对这样的场景，一般的做法就是 在返回结果中 解析json 后， 判断返回值，这样就会打乱 我们正常的 处理流程。然后，利用RxJava就可以这样处理</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">.map(new Func1&lt;Result&lt;List&lt;News<span class="meta">&gt;&gt;</span>, Result&lt;List&lt;News&gt;&gt;&gt;()</span><br><span class="line">&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public Result&lt;List&lt;News<span class="meta">&gt;&gt; </span>call(Result&lt;List&lt;News&gt;&gt; result)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (Result.TOKEN_CODE == result.getError_code())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="regexp">//</span> 跳转到用户登录页面</span><br><span class="line">      startActivity(new Intent(AppManager.getInstance().currentActivity(), LoginActivity.<span class="keyword">class</span>));</span><br><span class="line">      <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>对于这种类型的场景，一般需要构建全局的检测，那么按照RxJava 的方式， 只需通过<code>map()</code>来处理加工后再返回。具体的RxJava+Retrofit 处理方式可具体代码请参考<a href="https://github.com/yxcoding/HttpDemo" target="_blank" rel="external">Demo</a>&gt;&gt;&gt;retrofithttp 包以及RxJava+Retrofit 请求demo。</p>
<p>针对RxJava的简单介绍和RxJava结合Retrofit 的网络请求已经总结完了。总体来说， RxJava 在某种程度上，简化和清晰了异步事件序列的处理流程， 并且提供类似<code>map()</code>、<code>flatMap()</code> 等<code>lift()</code>原理的操作方式，使得RxJava相对于其他处理异步事件序列的方式 更为简单，方便和强大。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Paint、Canvas、Matrix使用讲解(一、Paint) [转载]]]></title>
      <url>http://yxcoding.github.io/2016/07/07/1467861978320/</url>
      <content type="html"><![CDATA[<p>CSDN上一篇描述Paint系列知识原理的好文，描述的非常详细。<a href="http://blog.csdn.net/tianjian4592/article/details/44336949" target="_blank" rel="external">原文地址</a><br><a id="more"></a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 网络请求框架哪家强?]]></title>
      <url>http://yxcoding.github.io/2016/06/24/1466752925430/</url>
      <content type="html"><![CDATA[<p>首先，我们来列一下目前一些知名的Android网络请求库：OKHttp、Android-async-http 、Volley、Retrofit，以上这些开源框架一直以来备受开发者的青睐，下面我们来统一说明一下各大网络请求框架的使用方法。<br><a id="more"></a></p>
<h1 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a><a href="http://square.github.io/okhttp/" target="_blank" rel="external">OkHttp</a></h1><p>OKHttp 是一个高效的HTTP去请求库，功能非常之强大：</p>
<ol>
<li>支持SPDY(Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验, 是HTTP协议的增强）,共享同一个Socket来处理同一个服务器的所有请求</li>
<li>如果SPDY不可用，则通过连接池来减少请求延时</li>
<li>无缝的支持GZIP来减少数据流量</li>
<li>缓存响应数据来减少重复的网络请求</li>
</ol>
<p>OkHttp 会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。<br><strong>查看android 4.4的源码就可以发现原来的HttpURLConnection 已经替换成OKHttp来实现了，所以不说他牛逼都不行。可惜OKHttp 现阶段还不支持异步请求的回调接口。</strong></p>
<blockquote>
<p>本博客Demo利用Android Studio 开发</p>
</blockquote>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>在build.gradle 中引入OkHttp 请求框架<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.squareup.okhttp3:okhttp:3.3.1'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 发送Get 请求</span><br><span class="line">* @param context  通过context.getClass().getName() 设置请求tag，用来取消请求</span><br><span class="line">* @param url</span><br><span class="line">* @param callback 基于okHttp Callback 封装的一层回调</span><br><span class="line">*/</span><br><span class="line">public void sendGetRequest(Context context, String url, HttpRequestCallback callback)</span><br><span class="line">&#123;</span><br><span class="line">    Request request = new Request.Builder().tag(getTagByContext(context)).url(url).get().build();</span><br><span class="line">    okHttpClient.newCall(request).enqueue(getCallback(context, callback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 发送POST请求</span><br><span class="line">* @param context   通过context.getClass().getName() 设置请求tag，用来取消请求</span><br><span class="line">* @param url</span><br><span class="line">* @param params    基于FormBody.Builder 封装的post请求参数对象</span><br><span class="line">* @param callback  基于okHttp Callback 封装的一层回调</span><br><span class="line">*/</span><br><span class="line">public void sendPostRequest(Context context, String url, RequestParams params, HttpRequestCallback callback)</span><br><span class="line">&#123;</span><br><span class="line">    Request request = new Request.Builder().tag(getTagByContext(context)).url(url).post(params.toParams()).build();</span><br><span class="line">    okHttpClient.newCall(request).enqueue(getCallback(context, callback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于OKHttp 不支持异步请求接口回调，所以Demo中重新封装了Callback利用Hanlder来处理请求回调，具体代码见<a href="https://github.com/yxcoding/HttpDemo" target="_blank" rel="external">Demo</a>&gt;&gt;&gt;okhttp 包。</p>
<h1 id="Android-async-http"><a href="#Android-async-http" class="headerlink" title="Android-async-http"></a><a href="http://loopj.com/android-async-http/" target="_blank" rel="external">Android-async-http</a></h1><p>这个开源框架是基于Apache’s HttpClient 实现的， 所有的请求都是独立在UI主线程之外，通过回调接口方法处理请求结果，其实内部也是通过Handler Message 机制传递消息。它有以下特性:</p>
<ol>
<li>采用异步http请求，并通过匿名内部类处理回调结果</li>
<li>http请求独立在UI主线程之外</li>
<li>采用线程池来处理并发请求</li>
<li>采用RequestParams类创建GET/POST参数</li>
<li>不需要第三方包即可支持Multipart file文件上传</li>
<li>大小只有25kb</li>
<li>自动为各种移动电话处理连接断开时请求重连</li>
<li>超快的自动gzip响应解码支持</li>
<li>使用BinaryHttpResponseHandler类下载二进制文件(如图片)</li>
<li>使用JsonHttpResponseHandler类可以自动将响应结果解析为json格式</li>
<li>持久化cookie存储，可以将cookie保存到你的应用程序的SharedPreferences中</li>
</ol>
<p>总体来说，Android-async-http 简单轻便实用，个人比较喜欢…</p>
<h2 id="配置环境-1"><a href="#配置环境-1" class="headerlink" title="配置环境"></a>配置环境</h2><p>在build.gradle 中引入Android-async-http 请求框架<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.loopj.android:android-async-http:1.4.9'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="GET-请求-1"><a href="#GET-请求-1" class="headerlink" title="GET 请求"></a>GET 请求</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 发送Get 请求</span><br><span class="line">* @param context  用于取消http请求的凭证</span><br><span class="line">* @param url</span><br><span class="line">* @param callback 异步请求回调接口</span><br><span class="line">*/</span><br><span class="line">public void sendGetRequest(Context context, String url, AsyncHttpResponseHandler callback)</span><br><span class="line">&#123;</span><br><span class="line">  asyncHttpClient.get(context, url, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="POST-请求-1"><a href="#POST-请求-1" class="headerlink" title="POST 请求"></a>POST 请求</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 发送POST 请求</span><br><span class="line">* @param context   用于取消http请求的凭证</span><br><span class="line">* @param url</span><br><span class="line">* @param params    请求参数回对象</span><br><span class="line">* @param callback  异步请求回调接口</span><br><span class="line">*/</span><br><span class="line">public void sendPostRequest(Context context, String url, RequestParams params, AsyncHttpResponseHandler callback)</span><br><span class="line">&#123;</span><br><span class="line">  asyncHttpClient.post(context, url, params, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Android-async-http 中封装了异步请求回调接口，可直接拿来使用。不用自己二次封装。同时可使用JsonHttpResponseHandler 类可以自动将响应结果解析为json格式。具体代码见<a href="https://github.com/yxcoding/HttpDemo" target="_blank" rel="external">Demo</a>&gt;&gt;&gt;asynhttp 包。</p>
<h1 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a><a href="http://square.github.io/okhttp/" target="_blank" rel="external">Volley</a></h1><p>Volley 是2013年Google I/O开发者大会上被提出来的，目的是让Android应用网络操作更方便快捷。Volley也支持不同线程异步执行请求从而避免主线程阻塞。作为Android 干爹强力推出的开源框架，这里必须支持一下。Volley 有以下特性:</p>
<ol>
<li>自动调度网络请求</li>
<li>多个并发的网络连接</li>
<li>通过使用标准的HTTP缓存机制保持磁盘和内存响应的一致</li>
<li>支持请求优先级</li>
<li>支持取消请求的强大API，可以取消单个请求或多个</li>
<li>易于定制</li>
<li>健壮性：便于正确的更新UI和获取数据</li>
<li>包含调试和追踪工具</li>
</ol>
<h2 id="配置环境-2"><a href="#配置环境-2" class="headerlink" title="配置环境"></a>配置环境</h2><p>在build.gradle 中引入Volley请求框架<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.android.volley:volley:1.0.0'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="GET-请求-2"><a href="#GET-请求-2" class="headerlink" title="GET 请求"></a>GET 请求</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Get 请求</span><br><span class="line">* @param context</span><br><span class="line">* @param url</span><br><span class="line">* @param callback</span><br><span class="line">*/</span><br><span class="line">public void sendGetRequest(Context context, String url, VolleyCallback callback)</span><br><span class="line">&#123;</span><br><span class="line">    StringRequest req = new StringRequest(Request.Method.GET, url, callback, callback);</span><br><span class="line">    req.setTag(context);</span><br><span class="line">    requestQueue.add(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="POST-请求-2"><a href="#POST-请求-2" class="headerlink" title="POST 请求"></a>POST 请求</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 发送Post请求</span><br><span class="line">* @param context</span><br><span class="line">* @param url</span><br><span class="line">* @param params</span><br><span class="line">* @param callback</span><br><span class="line">*/</span><br><span class="line">public void sendPostRequest(Context context, String url, final VolleyRequestParams params, VolleyCallback callback)</span><br><span class="line">&#123;</span><br><span class="line">    StringRequest req = new StringRequest(Request.Method.POST, url, callback, callback)</span><br><span class="line">	&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Map&lt;String, String&gt; getParams() throws AuthFailureError</span><br><span class="line">        &#123;</span><br><span class="line">            return params;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">    req.setTag(context);</span><br><span class="line">    requestQueue.add(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Volley 中通过RequestQueue 用来执行请求的请求队列，通过Request来构造一个请求对象。Volley提供了以下几种类型的Request:</p>
<ol>
<li>StringRequest 响应的主体为字符串</li>
<li>JsonArrayRequest 发送和接收JSON数组</li>
<li>JsonObjectRequest 发送和接收JSON对象</li>
<li>ImageRequest 发送和接收Image</li>
</ol>
<p>抽象了底层的Http Client等实现的细节， 为开发者提供了方便的接口。Demo中基于Response.Listener和Response.ErrorListener重新整合封装了一个异步请求回调接口VolleyCallback。具体代码见<a href="https://github.com/yxcoding/HttpDemo" target="_blank" rel="external">Demo</a>&gt;&gt;&gt;volleyhttp 包。</p>
<h1 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a><a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a></h1><p>Retrofit 和 OKHttp 一样，都是Square开源的网络请求框架， Retrofit 对 OKHttp做了封装。Retrofit 为Android网络请求提供了REST方式的HTTP请求。Retrofit通过接口方法注解的方式统一规范请求接口，例如：@GET、@POST、@Multipart 等等，相比其他其他的网络请求库，Retrofit 具有独特的使用方式，是一套RESTful 架构的客户端实现。提供了多种类型转JAVA对象的转换器。服务器端接口是是一套RESTful架构或者有多种数据返回格式的推荐使用这种方式。</p>
<h2 id="配置环境-3"><a href="#配置环境-3" class="headerlink" title="配置环境"></a>配置环境</h2><p>在build.gradle 中引入Retrofit 请求框架<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.squareup.retrofit2:retrofit:2.1.0'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="GET-请求-3"><a href="#GET-请求-3" class="headerlink" title="GET 请求"></a>GET 请求</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@GET(<span class="string">"onebox/news/query"</span>)</span><br><span class="line">Call&lt;Result&lt;List&lt;News<span class="meta">&gt;&gt;&gt; </span>getNewsList(@Query(<span class="string">"key"</span>) String key, @Query(<span class="string">"q"</span>) String q);</span><br></pre></td></tr></table></figure>
<h3 id="POST-请求-3"><a href="#POST-请求-3" class="headerlink" title="POST 请求"></a>POST 请求</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@POST(<span class="string">"onebox/news/query"</span>)</span><br><span class="line"> Call&lt;Result&lt;List&lt;News<span class="meta">&gt;&gt;&gt; </span>getNewsListByPost(@Query(<span class="string">"key"</span>) String key, @Query(<span class="string">"q"</span>) String q);</span><br></pre></td></tr></table></figure>
<p>Retrofit 和 OKHttp 一样，从2.0 开始，通过定义一个Call 来发起请求，并且可以通过这个call 对象调用call.cancel() 来取消请求。Retrofit 定义了retrofit2.Callback 的异步回调接口<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Callback&lt;T&gt; &#123;</span><br><span class="line">  void onResponse(Call&lt;T&gt; call, Response&lt;T&gt; response);</span><br><span class="line">  void onFailure(Call&lt;T&gt; call, Throwable t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个方法都是在主线程中被调用，通过定义泛型T来扩展返回的POJO对象。上文说到Retrofit 提供了JSON 转换器支持，通过设置<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addConverterFactory(GsonConverterFactory.create())</span><br></pre></td></tr></table></figure></p>
<p>来内部转换POJO对象。<br>以下为Retrofit 支持的格式转换类型：</p>
<ol>
<li>Gson: com.squareup.retrofit2:converter-gson</li>
<li>Jackson: com.squareup.retrofit2:converter-jackson</li>
<li>Moshi: com.squareup.retrofit2:converter-moshi</li>
<li>Protobuf: com.squareup.retrofit2:converter-protobuf</li>
<li>Wire: com.squareup.retrofit2:converter-wire</li>
<li>Simple XML: com.squareup.retrofit2:converter-simplexml</li>
<li>Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars<br>具体代码请参考<a href="https://github.com/yxcoding/HttpDemo" target="_blank" rel="external">Demo</a>&gt;&gt;&gt;retrofithttp 包。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上四种网络请求框架，各有各的特点：</p>
<ul>
<li>OKHttp 和 Retrofit 都是来自Square，质量和性能都很优秀。OKHttp 功能十分强大，可以应对几乎所有的商业场景应用，大家可以根据OKHttp 自由扩展和封装。</li>
<li>Retrofit 内部也是根据OkHttp 进行了扩展，它把http 请求处理机制交给了OKHttp处理。个人觉得Retrofit 更加人性化，利用RESTful 架构使得接口形式更加规范清晰统一。</li>
<li>Volley 除了是一个网络请求框架，还是一个图片加载框架，可以二合一使用。</li>
<li>Android-async-http 个人比较喜欢这个框架，简单方便，异步请求回调，文件上传和下载使用简单，对网络请求要求不是很高的项目完全和可以使用这个框架。可以这么说，Android-async-http 进行了高强度的封装， 使得开发者 白痴式的调用，让开发者更加关注于业务发开。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GitHub Top 100 的Android 开源库[转载]]]></title>
      <url>http://yxcoding.github.io/2016/06/23/1494933779424/</url>
      <content type="html"><![CDATA[<p>今天看到stormzhang发的一篇文章，觉得非常不错，特意转载一下，大家一起分享，<a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=402675429&amp;idx=1&amp;sn=ba3afd2069004b220eaa8a77fdecbaf7&amp;scene=23&amp;srcid=0327HSwrg5A4kpYmncHp8TgL#rd" target="_blank" rel="external">原文地址</a>，记录了github上关于android的排名前100的开源软件，都是干货<br><a id="more"></a></p>
<ol>
<li><p>React Native<br>这个是 Facebook 在 React.js Conf 2015 大会上推出的基于 JavaScript 的开源框架 React Native, 该框架结合了 Web 应用和 Native 应用的优势, 可以使用 JavaScript 来开发 iOS 和 Android 原生应用</p>
</li>
<li><p>Universal ImageLoader<br>ImageLoader 是最早开源的 Android 图片缓存库, 强大的缓存机制, 早期被广泛 Android 应用使用, 至今仍然有很多 Android 开发者在使用</p>
</li>
<li><p>RxJava<br>RxJava 是一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库, 简单来说它就是一个实现异步操作的库, RxJava 的优点在于一个词 “简洁”, 使用它就算你程序逻辑有多么复杂, 它依然能够保持简洁易懂</p>
</li>
<li><p>Retrofit<br>Retrofit 是 Square 公司出品的 HTTP 请求库, 同时是 Square 是最早开源项目之一, Retrofit 是目前 Android 最流行的 Http Client 库之一, 目前版本是 Retrofit2.0 Beta4, 越来越多 Android 开发者开始使用这个请求库了</p>
</li>
<li><p>OkHttp<br>OkHttp 是 Square 公司出品的 HTTP 另一个请求库, Google 不推荐人们使用 HttpClient, 可是 HttpURLConnection 实在是太难用了, 因此很多人使用了 OkHttp 来解决这问题, 据说 Android4.4 的源码中可以看到 HttpURLConnection 已经替换成 OkHttp 实现呢</p>
</li>
<li><p>SlidingMenu<br>一个侧滑菜单开源库, 在 Google 自己原生态的侧滑菜单 NavigationDrawer 没有出现之前, 这个库就已经被广泛使用, 可是到现在这个库已经被放弃了</p>
</li>
<li><p>Picasso<br>Picasso 是 Square 公司出品的一款图片缓存库, 主导者是 JakeWharton 大神</p>
</li>
<li><p>Android-Best-Practices<br>Android 开发最佳实践, 里面所介绍的经验都是来自于 Futurice 公司 Android 开发者, 介绍内容有 Android 开发规范、架构、布局技巧, 以及使用一些有助于快速开发相关工具等等, 非常适合新手去学习</p>
</li>
<li><p>EventBus<br>EventBus 是 Android 事件管理总线, 使用它可以替带 Android BroadCast, BroadCastReceiver, Handler 在 Activity, Fragment, Service, 线程之间传递消息, 大大简化了事件传递逻辑</p>
</li>
<li><p>android-async-http<br>android-async-http 是 Android 一款老牌异步请求库, 专门对 Android 在 Apache 的 HttpClient 基础上构建的异步 http 连接, 该库有很多特征, 例如: 库的 size 小, 支持文件上传不需使用第三方库支持, 内部使用线程池来处理并发, 等等</p>
</li>
<li><p>Fresco<br>Fresco 是 FaceBook 公司出品的一款图片缓存库, Fresco 是一个强大的图片加载组件, 支持加载 Gif 图和 WebP 格式, 支持 Android2.3(API level 9) 及其以上系统, Fresco 中设计了 Image pipeline 和 Drawees 两个模块各施其职, 使得图片完美加载出来, 想知道更多 image pipeline 和 Drawees 有关于它的特性, 可以到它<a href="http://fresco-cn.org/" target="_blank" rel="external">官方平台</a>看介绍</p>
</li>
<li><p>ZXing<br>ZXing 是二维码领域中名气最大的开源项目, 它提供了多个平台的二维码/条形码扫描解决方案, 拥有扫描快, 识别率高, 使用简单等特点</p>
</li>
<li><p>LeakCanary<br>LeakCanary 是 Square 公司出的一款检测内存泄露工具, 该工具能帮助你在开发阶段方便的检测出内存泄露的问题, 使用起来非常简单方便</p>
</li>
<li><p>Butter Knife<br>由 JakeWharton 大神开发出来的, ButterKnife 是 View 注入框架, 使用它为了简写很多 findViewById 代码, 同时还支持 View 的一些事件处理函数</p>
</li>
<li><p>MPAndroidChart<br>MPAndroidChart 是一款强大的 Android 图表库, 支持各种各样图表显示, 能想到的图表样式这里几乎都有, 图表还支持选择, 拖放和缩放动画效果</p>
</li>
<li><p>ActionBarSherlock<br>ActionBarSherlock 这个库是 JakeWharton 大神开发出来支持 Android3.0 以下版本的, 后来慢慢的 Google 也提供了 AppCompat 库来支持 Android3.0 以下版本使用 ActionBar, 因此不建议再使用这个库了</p>
</li>
<li><p>AndroidAnnotations<br>AndroidAnnotations 是一个能够让你快速进行 Android 开发的开源框架, 它能让你专注于真正重要的地方, 使代码更加精简, 使项目更加容易维护, 它的目标就是 “Fast Android Development.Easy maintainance”</p>
</li>
<li><p>ViewPagerIndicator<br>由 JakeWharton 大神开发出来的一个 ViewPager 指示器, 使用起来简单方便, 可高度定制, 开发出各种各样动画效果</p>
</li>
<li><p>Glide<br>Glide 是 Google 员工的开源项目, 广泛应用于 Google 一些 App 上, 在2014年 Google I/O 大会上被推荐使用, Glide 和 Picasso 被人拿来比较研究过, Glide 与 Picasso 有 90% 的相似度, 但在一些细节上还是有点区别的, 各有各优缺点看君选择</p>
</li>
<li><p>HomeMirror<br>开发者是由一名程序媛 Hannah Mittelstaedt , HomeMirror 是一款 Android 镜子应用, 目前它能实现日期, 时间, 天气, 生日信息, 事件提醒器, 骑车天气的推荐, 股票信息, XKCD 漫画网站的新帖等等</p>
</li>
<li><p>Android-PullToRefresh<br>一个强大的拉动刷新开源项目，支持各种控件下拉刷新，ListView、ViewPager、WebView、ExpandableListView、GridView、ScrollView、Horizontal ScrollView、Fragment 上下左右拉动刷新, 不过现在这个项目已经停止维护更新了</p>
</li>
<li><p>MaterialDesignLibrary<br>这个库控件都是遵循了 Google Material Design 设计规范开发出来, 例如有: Flat Button, Rectangle Button, CheckBox, Switch, Progress bar circular indeterminate 等等</p>
</li>
<li><p>PhotoView<br>PhotoView 是 ImageView 的子类, 支持所有 ImageView 的源生行为, 例如: 支持 Pinch 手势自由缩放, 支持双击放大/还原, 支持平滑滚动等等, 并且非常方便的与 ImageLoader/Picasso 之类的网络图片读取库集成使用, 还方便的与 ViewPager 等同样支持滑动手势的控件集成</p>
</li>
<li><p>RxAndroid<br>由 JakeWharton 大神主导开发的项目, RxAndroid 是 RxJava 的一个针对 Android 平台的扩展, 主要用于 Android 开发</p>
</li>
<li><p>Material Dialogs<br>Material Dialogs 是一个可高度定制易用, 符合 Material Design 风格的 Dialogs, 兼容 Android API8 以上版本, 个人使用感觉它完全可替代 Android 原生那个, 比原生那个更加简单易用</p>
</li>
<li><p>AndroidObservableScrollView<br>ObservableScrollView 是一款用于在滚动视图中观测滚动事件的 Android 库, 它能够轻而易举地与 Android 5.0 Lollipop 引进的工具栏 (Toolbar) 进行交互, 还可以帮助开发者实现拥有 Material Design 应用视觉体验的界面外观, 支持ListView, ScrollView, WebView, RecyclerView, GridView组件</p>
</li>
<li><p>Android-Bootstrap<br>Android 版的 Bootstrap, 利用这个库能够实现很多 Bootstrap 样式风格, 之前有学过 Html 的人就知道 Bootstrap 是什么玩意啦</p>
</li>
<li><p>AndroidSwipeLayout<br>开发者是代码家, AndroidSwipeLayout 是一个支持ListView, GridView, ViewGroup等等左右上下滑动出操作菜单, 类似 qq 消息列表向左滑动显示出多某条信息的操作菜单</p>
</li>
<li><p>Dagger<br>Dagger 是 Square 公司出品的一个针对 Android 和 Java 的快速依赖注入器, 能够有效减少你敲代码量</p>
</li>
<li><p>ListViewAnimations<br>一个轻轻松松给 Android ListView 添加动画效果的库, 支持的动画有: Alpha, SwingRightIn, SwingLeftIn, SwingBottomIn, SwingRightIn and ScaleIn等等, 使用它能很容易就实现帅爆的效果</p>
</li>
<li><p>PagerSlidingTabStrip<br>PagerSlidingTabStrip 是一个给 Android ViewPager添加上 ViewPager 滑动指示器, 从 GitHub 上面看, 这个库似乎没有人在维护了, 请谨慎使用该库</p>
</li>
<li><p>AndroidViewAnimations<br>开发者是代码家, 这个库实现很多很酷炫的 Android 动画, 动画效果是借鉴 Animate.css 来实现的, 非常酷, 而且这个使用起来也是非常简单</p>
</li>
<li><p>AndroidSlidingUpPanel<br>AndroidSlidingUpPanel 是一个上拉面板, 就是向上滑动的时候往上飞出一个显示面板控件, 该库效果在 Google Music, Google Maps and Rdio等 App 中用到</p>
</li>
<li><p>MaterialDrawer<br>MaterialDrawer 是一个类似 Google 官方 NavigationView 侧滑显示控件, 个人认为 NavigationView 并没有 MaterialDrawer 实用, 因为 NavigationView 自由度不是很好, 很多都写死了不可以自由定义布局, 而 MaterialDrawer 能够实现跟 NavigationView 一样的效果, 同时还支持自定义效果, 自由度非常高</p>
</li>
<li><p>Material-Animations<br>Material-Animations 是一个很好过渡动画库, 可以应用于 Activity 与 Activity 之间的跳转, Fragment 与 Fragment 之间的跳转, 以及各个 View 变化前后的过渡动画</p>
</li>
<li><p>MaterialViewPager<br>一个简单易用 Material Design 风格的 ViewPager 库</p>
</li>
<li><p>Ion<br>ion 是一个让 Android 的网络操作变得极其简单, 支持异步获取和处理JSON, 支持 Android 文件下载 (同时支持下载进度条绑定), 支持安全链接和代理</p>
</li>
<li><p>Stetho<br>Stetho是 Facebook 出品的一个强大的 Android 调试工具,使用该工具你可以在 Chrome Developer Tools查看App的布局, 网络请求(仅限使用Volley, okhttp的网络请求库), sqlite, preference, 一切都是可视化的操作,无须自己在去使用adb, 也不需要root你的设备</p>
</li>
<li><p>Fastjson<br>Fastjson是一个Java语言编写的高性能功能完善的JSON库。它采用一种“假定有序快速匹配”的算法，把JSON Parse的性能提升到极致，是目前Java语言中最快的JSON库。Fastjson接口简单易用，已经被广泛使用在缓存序列化、协议交互、Web输出、Android客户端等多种应用场景</p>
</li>
<li><p>Card Library<br>Cardslib 是早期由 Gabriele Mariotti 开发的一个为开发者方便实现各种 Card UI 的 Android 开源代码库, 后来 Google 官方提供自己封装了 CardView 在 v7 包下, 使用 Google 官方的可以完全替代了这个库, 因此这个也被弃用了</p>
</li>
<li><p>android-Ultra-Pull-To-Refresh<br>开发者是廖祜秋, 这个是一个非常强大的下拉刷新库, 继承 ViewGroup 可以包含任何 View, 功能甚至比 SwipeRefreshLayout 强大, 使用起来也非常容易, 还可以自由定制自己的 UI 样式</p>
</li>
<li><p>greenDAO<br>greenDAO 是一个可以帮助 Android 开发者快速将 Java 对象映射到 SQLite 数据库的表单中的 ORM解决方案, 通过使用一个简单的面向对象 API, 开发者可以对 Java 对象进行存储, 更新, 删除和查询, greenDAO 相对 OrmLite, AndrORM 这两个 ORM 开源库, 性能是最高的</p>
</li>
<li><p>AndroidStaggeredGrid<br>AndroidStaggeredGrid 是一个支持多列并且每一行的 item 大小不一, 交错排列的 GridView, 就是实现瀑布流样式效果, 目前该库已经被弃用了, 开发者建议我们使用 Google 官方控件 RecyleView 中的 StaggeredGridLayoutManager 布局来实现瀑布流效果</p>
</li>
<li><p>Otto<br>Otto 是 Square 公司出的一个事件库 (pub/sub 模式), 用来简化应用程序组件之间的通讯, otto 修改自 Google 的 Guava 库, 专门为 Android 平台进行了优化, 与上面介绍的 EventBus 相比, 两个库各有各的优点, 完全取决于我们自己项目的需求来选择它们哪一个</p>
</li>
<li><p>xUtils<br>xUtils 是一个快速开发框架, 里面包含 DbUtils, ViewUtils, HttpUtils, BitmapUtils 四大模块, 可用于快速开发, 支持大文件上传, 拥有更加灵活的 ORM, 最低兼容 Android 2.2</p>
</li>
<li><p>Realm Java<br>Realm 一个轻量的 Android 版本的数据存储库, 比 Android 原生系统的 SQLite 更加简洁快速对数据进行操作</p>
</li>
<li><p>AndroidCleanArchitecture<br>CleanArchitecture 是一个非常典型使用 MVP 架构的项目, 大家如果还没有理解 MVP 架构的可以看看这个项目</p>
</li>
<li><p>StickyListHeaders<br>StickyListHeaders 是一个实现能够固定在屏幕顶部的ListView Section Header库, 就是当前 section 的 header 固定在屏幕顶部, 当滑动到其他 section 时, 其他 section 的 header 会代替之前的 section 的 header, 固定到屏幕顶部, 类似于 Android4.0 的手机通讯录的效果</p>
</li>
<li><p>AppIntro<br>AppIntro 是一个让人轻松快速搭建漂亮酷炫的引导页库</p>
</li>
<li><p>ActiveAndroid<br>ActiveAndroid 是采用Rails中的「Active Record」架构模式设计的适用于 Android 平台的轻量级 ORM 架构, 几乎可以不用写任何 SQL 代码实现快速开发</p>
</li>
<li><p>Android Volley<br>Volley 是谷歌官方开发团队在 2013 年 Google I/O 大会推出的一个新的网络通信框架, 这个框架把 AsyncHttpClient 和 Universal-Image-Loader 的优点集于了一身,既可以像AsyncHttpClient 一样非常简单地进行 HTTP 通信,也可以像 Universal-Image-Loader 一样轻松加载网络上的图片, 这个库并不是官方的, 只是托管同步在 Maven,  官方只提供的 Jar 包</p>
</li>
<li><p>TwoWayView<br>TwoWayView 是简化 RecyclerView 开发的一个库, 可以在其 Base LayoutManager 基础上构建各种各样的布局, 该库内置了几个常用布局 List, Grid, Staggered Grid,Spannable Grid</p>
</li>
<li><p>ShowcaseView<br>ShowcaseView 是一个非常适合用于对用户进行第一次使用进行指导的库,使用起来非常简单还可以自定义样式</p>
</li>
<li><p>Calligraphy<br>Calligraphy 是一个用来简化 Android 应用使用自定义字体的类库, 该类库会自动查找应用中的 TextView 并设置其使用的字体</p>
</li>
<li><p>NineOldAndroids<br>NineOldAndroids 由 JakeWharton 大神开发的一个向下兼容的动画库, 主要是使低于API 11的系统也能够使用 View 的属性动画, 不过现在 JakeWharton 大神已经不推荐使用该库, 而是推荐我们使用官方封装在 Support 库里面的动画</p>
</li>
<li><p>FloatingActionButton<br>FloatingActionButton 是一个悬浮操作按钮, 官方在 Support Design 包下也有封装一个类似这个库效果的 FloatingActionButton, 值得说明的是这个库是早在官方封装之前就存在的, 个人感觉这个库比官方那个更加好用</p>
</li>
<li><p>CircleImageView<br>CircleImageView 是一个轻松帮你实现圆形效果 ImageView 图片库, CircleImageView 是基于 ImageView 扩展出来, 因此它拥有 ImageView 控件所有属性, 简单易用值得你使用的库</p>
</li>
<li><p>Material<br>Material 是将 Material Design 风格控件封装在该库当中, 目前封装有Progress, Button, Switch, Slider, Spinner, Text Field, TabPageIndicator, SnackBar, Dialog, BottomSheetDialog, Dynamic theme</p>
</li>
<li><p>ActionBar-PullToRefresh<br>ActionBar-PullToRefresh 是一个下拉刷新, 下拉刷新时在 ActionBar 出现加载中提示的库</p>
</li>
<li><p>FloatingActionButton<br>又一个悬浮操作按钮库, 该库添加支持监听滑滚动事件, 当向下滑时按钮隐藏, 向上滑时按钮显示, 还有动画效果, 支持监听 ListView, ScrollView, RecylerView</p>
</li>
<li><p>AndroidAsync<br>AndroidAsync 是一款基于 NIO 的低端 Android 异步 socket, http (client+server), websocket 和 socket.io 网络通信协议类库</p>
</li>
<li><p>Rebound<br>Rebound 是 Facebook 推出的一个弹性动画库, 可以让动画看起来真实自然, 像真实世界的物理运动, 带有力的效果, 使用的参数则是 Facebook 的 origami 中使用的</p>
</li>
<li><p>android-common-lib<br>android-common-lib 是 Trinea 大神收集的一些开发通用的缓存, 公共 View 以及一些常用工具类</p>
</li>
<li><p>RippleEffect<br>RippleEffect 是一个实现在 Android 任何组件点击出现 Material Design 的波纹效果, 向下兼容到 Android API9</p>
</li>
<li><p>SmoothProgressBar<br>SmoothProgressBar 是一个帮你的 App 方便实现可定制, 平滑动画的水平滚动进度条库</p>
</li>
<li><p>RecyclerView Animators<br>RecyclerView Animators 是一个对 Recycler 控件的 Item 添加以及删除增加动画效果, 动画效果有Scale, Fade, Flip, Slide 里面各种各样效果</p>
</li>
<li><p>circular-progress-button<br>一个带进度显示的 Button, 效果和动画做的都非常赞</p>
</li>
<li><p>Droid Plugin<br>DroidPlugin 是 360 手机助手在 Android 系统上实现了一种新的插件机制: 它可以在无需安装, 修改的情况下运行APK文件, 此机制对改进大型APP的架构, 实现多团队协作开发具有一定的好处</p>
</li>
<li><p>dynamic-load-apk<br>开发者是singwhatiwanna, 是《Android 开发艺术探索》书籍的作者, 这个是作者联合另两位开发者啸(时之沙)和宋思宇花了几个月时间研究出来的 Apk 动态加载框架, 想了解更多关于这框架可到作者博客看这篇文章「<a href="http://blog.csdn.net/singwhatiwanna/article/details/39937639」" target="_blank" rel="external">http://blog.csdn.net/singwhatiwanna/article/details/39937639」</a></p>
</li>
<li><p>ExoPlayer<br>ExoPlayer 是Google 开发团队开源出来的一个媒体播放库, 比 Android 框架原生的 MediaPlayer 拥有更多优点支持动态的自适应流 HTTP(DASH) 和 平滑流, 支持高级的HLS特性, 支持自定义和扩治你的使用场景等等</p>
</li>
<li><p>Crouton<br>Crouton 是一个显示提示信息的显示工具类, 可以用来代替Toast, 默认显示在窗口的顶部, 可以按队列一个接着一个显示, 不过该库已经被弃用, 不推荐使用</p>
</li>
<li><p>RoboSpice<br>RoboSpice 是一个使你建立异步的长时间的运行任务异常轻松的一个网络库，在网络请求，缓存支持，和提供开箱即用的rest请求方面尤为强大</p>
</li>
<li><p>Hugo<br>Hugo 是 JakeWharton 大神推出的一个用于打印 Log, hugo 是基于注解被调用的, 引入相关依赖后, 在方法上加上 @DebugLog 即可输出 Log, 使用非常简单</p>
</li>
<li><p>AsyncHttpClient<br>AsyncHttpClient 是又一款 Android 异步请求库, 该库支持 WebSocket 协议, 使用起来也比较简单易用</p>
</li>
<li><p>UltimateRecyclerView<br>UltimateRecyclerView 是一个功能强大的 RecyclerView(advanced and flexible version of ListView), 包括了下拉刷新, 加载更多, 多种动画, 空数据提示, 拖动排序, 视差处理, 工具栏渐变, 滑动删除, 自定义floating button, 多种刷新效果, scrollbar, sticky header, 多 layout 支持等等元素, 而且使用起来跟 RecyclerView 一样的方便</p>
</li>
<li><p>MaterialEditText<br>MaterialEditText 是就职于 Flipboard 的员工 「扔物线」开发的, 在 AppCompat v21 中也提供了 Material Design 的控件 EditText, 可是由于比较难用, 没有提供设置颜色的 Api, 于是就产生这个第三方库</p>
</li>
<li><p>Side Menu<br>Side Menu 是 「Yalantis」组织开源出来, 该组织因开源出一些动画很棒的开源库为大家所熟知该库是其中一个, 该库是提供翻页动画效果的侧边菜单, 动画体验超赞的</p>
</li>
<li><p>DragSortListView<br>DragSortListView 是一个可以实现拖动排序, 滑动删除的 listview 控件, 注意的是作者对该库已经放弃维护更新了, 不过感兴趣的人可以去研究一下</p>
</li>
<li><p>TimesSquare<br>TimesSquare 是 Square 公司出品的一款显示日历选择日期的控件, 可以让用户选择多个日期</p>
</li>
<li><p>GreenDroid<br>GreenDroid 是一个封装好的 Android UI 界面库, 不过改库已经被弃用了，不建议使用</p>
</li>
<li><p>Logger<br>Logger 是一个简单, 漂亮, 强大 Android 打印日志库</p>
</li>
<li><p>Acra<br>Acra 是一个能够让 Android 应用自动将崩溃报告以谷歌文档电子表的形式进行发送的库, 旨在当应用发生崩溃或出现错误行为时, 开发者可以获取到相关数据</p>
</li>
<li><p>FadingActionBar<br>FadingActionBar 是一个支持 ListView, ScrollView, WebView 向下滚动时逐渐显示 ActionBar 库</p>
</li>
<li><p>AndroidImageSlider<br>AndroidImageSlider 库开发者是代码家, 该库是为 Banner 图片滑动提供多种动画效果, 还可以轻易为 Banner 加载网络图片</p>
</li>
<li><p>SystemBarTint<br>SystemBarTint 是一个实现沉浸式状态栏库, 适用于 Android 系统 4.4 其以上的版本</p>
</li>
<li><p>MenuDrawer<br>MenuDrawer 是一款滑出式菜单库, 通过拖动屏幕边缘滑出菜单, 支持屏幕上下左右划出, 支持当前 View 处于上下层, 支持 Windows 边缘, ListView 边缘, ViewPager 变化划出菜单等</p>
</li>
<li><p>RoundedImageView<br>RoundedImageView 一个快速支持图片圆角显示效果的库, 该库特点是能快速加载, 为了提高加载速度, 该库不用创建原始位图的副本, 不使用clipPath, 不使用 setXfermode 裁剪的位图等方式来实现 ImageView 圆角, 使用也非常简单</p>
</li>
<li><p>Afinal<br>Afinal 是一个 android 的 sqlite orm 和 ioc 框架, 同时封装了 android 中的 http 框架, 使其更加简单易用, 使用 finalBitmap, 无需考虑 bitmap 在 android 中加载的时候 oom 的问题和快速滑动的时候图片加载位置错位等问题, Afinal 的宗旨是简洁, 快速, 约定大于配置的方式, 尽量一行代码完成所有事情</p>
</li>
<li><p>android-pulltorefresh<br>一个强大的拉动刷新开源项目, 支持各种控件下拉刷新, ListView, ViewPager, WebView, ExpandableListView, GridView, ScrollView, Horizontal, ScrollView, Fragment 上下左右拉动刷新, 并且它实现的下拉刷新 ListView 在 item 不足一屏情况下也不会显示刷新提示, 体验更好, 但是该库已经停止维护, 因此不建议使用, 可考虑使用 Android-Ultra-Pull-to-Refresh</p>
</li>
<li><p>Bolts-Android<br>Bolts 是一款底层类库集合, 在后台实现异步操作, 并提供接口反馈当前异步执行的程度 (可以通过接口实现UI进度更新), 最后反馈执行的结果给UI主线程, 与AsyncTask比较: (1)使用的是无大小限制的线程池; (2)任务可组合可级联,防止了代码耦合</p>
</li>
<li><p>NumberProgressBar<br>NumberProgressBar 开发者是代码家, 这是一个带简约性感数字显示的进度条库, 使用非常简单方便</p>
</li>
<li><p>SwipeBackLayout<br>SwipeBackLayout 是一个支持屏幕上下左右滑动返回上层 Activity, 关闭当前 Activity, 类似简书 App</p>
</li>
<li><p>android-gif-drawable<br>一个支持 gif 显示的 view, 用 jni 实现的, 编译生成 so 库后直接 xml 定义 view 即可, 简单易用</p>
</li>
<li><p>Vitamio<br>Vitamio 是一款 Android 与 iOS 平台上的全能多媒体开发框架, 特点：(1) 全面支持硬件解码与 GPU 渲染, (2) 能够流畅播放 720P 甚至 1080P 高清 MKV, FLV, MP4, MOV, TS, RMVB 等常见格式的视频, (3) 在 Android 与 iOS 上跨平台支持 MMS, RTSP, RTMP, HLS(m3u8)等常见的多种视频流媒体协议, 包括点播与直播</p>
</li>
<li><p>SmartTabLayout<br>SmartTabLayout 是一个自定义的 Tab title strip, 基于 Google Samples 中的 android-SlidingTabBasic 项目, 滑动时 Indicator 可平滑过渡</p>
</li>
<li><p>uCrop<br>uCrop 是<a href="https://yalantis.com/" target="_blank" rel="external">Yalantis</a> 组织开源的图片裁剪库, 支持缩放, 旋转图片, 支持各种比例的裁剪框, 非常强大的一个图片裁剪库</p>
</li>
<li><p>android-crop<br>又一个图片裁剪库, 向下兼容到 Api 10, 个人感觉这个库并没有比上面介绍的 uCrop 强大</p>
</li>
<li><p>HoloEveryWhere<br>HoloEveryWhere 是一套 Android 开发库, 提供了全套 Holo Style 控件, 它的外观与功能和标准 Holo Style 控件基本相同, 唯一不同的是它可以运行在低于 4.0 版本的 Android 系统上</p>
</li>
<li><p>AVLoadingIndicatorView<br>AVLoadingIndicatorView 库含有各种各样漂亮的加载动画效果, 使用起来也非常简单, 和平时使用 ProgressBar 一样</p>
</li>
<li><p>Sweet Alert Dialog<br>Android 版的 SweetAlert, 清新文艺, 快意灵动的甜心弹框, 灵感来源于 JS 版「SweetAlert」</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux MySql 设置远程登录权限]]></title>
      <url>http://yxcoding.github.io/2016/06/23/1474977250401/</url>
      <content type="html"><![CDATA[<p>在已经安装好mysql 的linux服务器上，3360端口默认监听的是127.0.0.1也就是本地地址，要想远程登录mysql服务器，必须更改监听地址…<br><a id="more"></a><br><img src="http://7xprrr.com1.z0.glb.clouddn.com//image/20160108/1452251700895098190.jpg" alt=""></p>
<p>可以使用命令  netstat -an | grep 3306 查看3306端口<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp	 <span class="number">0</span>	<span class="number">0</span> <span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span><span class="symbol">:</span><span class="number">3306</span>  <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span><span class="symbol">:*</span>   LISTEN</span><br></pre></td></tr></table></figure></p>
<p>修改地址:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/mysql</span><br><span class="line">sudo vi my.cnf</span><br></pre></td></tr></table></figure></p>
<p>找到 bind-address = 127.0.0.1 注释掉 然后保存重启mysql服务</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux Mysql 解决中文乱码的问题]]></title>
      <url>http://yxcoding.github.io/2016/06/23/1474977250402/</url>
      <content type="html"><![CDATA[<p>Linux 下Mysql 默认字符集并不是UTF-8,所以只要将mysql的默认字符集修改成UTF-8即可，可以使用命令查看</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  show variables like <span class="string">'character%'</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>显示结果如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------+----------------------------+ </span><br><span class="line"><span class="params">| Variable_name |</span> Value <span class="params">| </span><br><span class="line">+--------------------------+----------------------------+ </span><br><span class="line">|</span> character_set_client <span class="params">| latin1 |</span> </span><br><span class="line"><span class="params">| character_set_connection |</span> latin1 <span class="params">| </span><br><span class="line">|</span> character_set_database <span class="params">| latin1 |</span> </span><br><span class="line"><span class="params">| character_set_filesystem |</span> binary <span class="params">| </span><br><span class="line">|</span> character_set_results <span class="params">| latin1 |</span> </span><br><span class="line"><span class="params">| character_set_server |</span> latin1 <span class="params">| </span><br><span class="line">|</span> character_set_system <span class="params">| utf8 |</span> </span><br><span class="line"><span class="params">| character_sets_dir |</span> /usr/share/mysql/charsets/ <span class="params">| </span><br><span class="line">+--------------------------+----------------------------+</span></span><br></pre></td></tr></table></figure></p>
<p>进入/etc/mysql/my.cnf 在相应模块下 添加编码设置</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">[mysql]</span><br><span class="line">no-auto-rehash</span><br></pre></td></tr></table></figure>
<p>修改完成后保存， service mysql restart 重启mysql服务…</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Studio 多渠道打包，自定义APK 名称]]></title>
      <url>http://yxcoding.github.io/2016/06/23/1474977250403/</url>
      <content type="html"><![CDATA[<p>使用Android Studio 有一段时间了， 让我总结下使用感受，那就是 “爽”！！！<br>由于公司项目android版渠道比较多， 所以打包的时候一般都会使用多渠道打包。而AS 为我们提供了很方便很牛逼的脚本工具Gradle，废话不多说<br><a id="more"></a></p>
<p><img src="http://makers-with-myson.blog.so-net.ne.jp/_images/blog/_786/makers-with-myson/m_520android20studio20startup.png" alt=""></p>
<p>首先在项目底下的 build.gradle 文件中的 android 节点 添加 productFlavors 节点 ， 如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//渠道列表</span><br><span class="line">productFlavors &#123;</span><br><span class="line">  pc &#123; </span><br><span class="line">  	manifestPlaceholders = [CHANNEL_NAME: "pc"]</span><br><span class="line">  &#125;</span><br><span class="line">  s360&#123;        </span><br><span class="line">  	manifestPlaceholders = [CHANNEL_NAME: "s360"]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 CHANNEL_NAME 是 AndroidManifest.xml 中添加 umeng 渠道占位符</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data </span><br><span class="line">    <span class="symbol">android:</span>name=<span class="string">"UMENG_CHANNEL"</span>    </span><br><span class="line">    <span class="symbol">android:</span>value=<span class="string">"$&#123;CHANNEL_NAME&#125;"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/meta-data&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时也在android 节点下 添加 以下脚本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//PK打包重新命名</span><br><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    variant.outputs.each &#123; output -&gt;        </span><br><span class="line">        def appName = 'your app name'        </span><br><span class="line">        def buildName</span><br><span class="line">        variant.productFlavors.each &#123; product -&gt;</span><br><span class="line">            buildName = product.name</span><br><span class="line">        &#125;</span><br><span class="line">        output.outputFile = new File(output.outputFile.parent, appName + "_" + </span><br><span class="line">        getVersionNameFromManifest() + "_" + buildName + ".apk");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们的版本号一般配置在AndroidManifest.xml 中， 所以利用 getVersionFromManifest() 方法获取其中的版本号(versionName)<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//从androidManifest.xml中获取版本号</span><br><span class="line">def getVersionFromManifest() &#123;    </span><br><span class="line">    def manifestParser = new com.android.builder.core.DefaultManifestParser()    </span><br><span class="line">    return manifestParser.getVersionName(android.sourceSets.main.manifest.srcFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>~~~ 好了， 直接 Build-&gt;Generate Signed APK ，然后选择你要打包的渠道和目录</p>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[读书]]></title>
      <url>http://yxcoding.github.io/reading/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>http://yxcoding.github.io/about/index.html</url>
      <content type="html"><![CDATA[<p>大家好，我是yxdroid。欢迎来到我的个人技术博客。</p>
<p>自我总结，提高自我，归纳分享</p>
]]></content>
    </entry>
    
  
</search>
